(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
	typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactIntl = {}, global.React));
}(this, (function (exports, React) { 'use strict';

	function _interopNamespace(e) {
		if (e && e.__esModule) { return e; } else {
			var n = Object.create(null);
			if (e) {
				Object.keys(e).forEach(function (k) {
					if (k !== 'default') {
						var d = Object.getOwnPropertyDescriptor(e, k);
						Object.defineProperty(n, k, d.get ? d : {
							enumerable: true,
							get: function () {
								return e[k];
							}
						});
					}
				});
			}
			n['default'] = e;
			return Object.freeze(n);
		}
	}

	var React__namespace = /*#__PURE__*/_interopNamespace(React);

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var types = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var TYPE;
	(function (TYPE) {
	    /**
	     * Raw text
	     */
	    TYPE[TYPE["literal"] = 0] = "literal";
	    /**
	     * Variable w/o any format, e.g `var` in `this is a {var}`
	     */
	    TYPE[TYPE["argument"] = 1] = "argument";
	    /**
	     * Variable w/ number format
	     */
	    TYPE[TYPE["number"] = 2] = "number";
	    /**
	     * Variable w/ date format
	     */
	    TYPE[TYPE["date"] = 3] = "date";
	    /**
	     * Variable w/ time format
	     */
	    TYPE[TYPE["time"] = 4] = "time";
	    /**
	     * Variable w/ select format
	     */
	    TYPE[TYPE["select"] = 5] = "select";
	    /**
	     * Variable w/ plural format
	     */
	    TYPE[TYPE["plural"] = 6] = "plural";
	    /**
	     * Only possible within plural argument.
	     * This is the `#` symbol that will be substituted with the count.
	     */
	    TYPE[TYPE["pound"] = 7] = "pound";
	    /**
	     * XML-like tag
	     */
	    TYPE[TYPE["tag"] = 8] = "tag";
	})(TYPE = exports.TYPE || (exports.TYPE = {}));
	var SKELETON_TYPE;
	(function (SKELETON_TYPE) {
	    SKELETON_TYPE[SKELETON_TYPE["number"] = 0] = "number";
	    SKELETON_TYPE[SKELETON_TYPE["dateTime"] = 1] = "dateTime";
	})(SKELETON_TYPE = exports.SKELETON_TYPE || (exports.SKELETON_TYPE = {}));
	/**
	 * Type Guards
	 */
	function isLiteralElement(el) {
	    return el.type === TYPE.literal;
	}
	exports.isLiteralElement = isLiteralElement;
	function isArgumentElement(el) {
	    return el.type === TYPE.argument;
	}
	exports.isArgumentElement = isArgumentElement;
	function isNumberElement(el) {
	    return el.type === TYPE.number;
	}
	exports.isNumberElement = isNumberElement;
	function isDateElement(el) {
	    return el.type === TYPE.date;
	}
	exports.isDateElement = isDateElement;
	function isTimeElement(el) {
	    return el.type === TYPE.time;
	}
	exports.isTimeElement = isTimeElement;
	function isSelectElement(el) {
	    return el.type === TYPE.select;
	}
	exports.isSelectElement = isSelectElement;
	function isPluralElement(el) {
	    return el.type === TYPE.plural;
	}
	exports.isPluralElement = isPluralElement;
	function isPoundElement(el) {
	    return el.type === TYPE.pound;
	}
	exports.isPoundElement = isPoundElement;
	function isTagElement(el) {
	    return el.type === TYPE.tag;
	}
	exports.isTagElement = isTagElement;
	function isNumberSkeleton(el) {
	    return !!(el && typeof el === 'object' && el.type === 0 /* number */);
	}
	exports.isNumberSkeleton = isNumberSkeleton;
	function isDateTimeSkeleton(el) {
	    return !!(el && typeof el === 'object' && el.type === 1 /* dateTime */);
	}
	exports.isDateTimeSkeleton = isDateTimeSkeleton;
	function createLiteralElement(value) {
	    return {
	        type: TYPE.literal,
	        value: value,
	    };
	}
	exports.createLiteralElement = createLiteralElement;
	function createNumberElement(value, style) {
	    return {
	        type: TYPE.number,
	        value: value,
	        style: style,
	    };
	}
	exports.createNumberElement = createNumberElement;
	});

	var skeleton = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	/**
	 * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
	 * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js
	 * with some tweaks
	 */
	var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
	/**
	 * Parse Date time skeleton into Intl.DateTimeFormatOptions
	 * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
	 * @public
	 * @param skeleton skeleton string
	 */
	function parseDateTimeSkeleton(skeleton) {
	    var result = {};
	    skeleton.replace(DATE_TIME_REGEX, function (match) {
	        var len = match.length;
	        switch (match[0]) {
	            // Era
	            case 'G':
	                result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';
	                break;
	            // Year
	            case 'y':
	                result.year = len === 2 ? '2-digit' : 'numeric';
	                break;
	            case 'Y':
	            case 'u':
	            case 'U':
	            case 'r':
	                throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');
	            // Quarter
	            case 'q':
	            case 'Q':
	                throw new RangeError('`q/Q` (quarter) patterns are not supported');
	            // Month
	            case 'M':
	            case 'L':
	                result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];
	                break;
	            // Week
	            case 'w':
	            case 'W':
	                throw new RangeError('`w/W` (week) patterns are not supported');
	            case 'd':
	                result.day = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'D':
	            case 'F':
	            case 'g':
	                throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');
	            // Weekday
	            case 'E':
	                result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';
	                break;
	            case 'e':
	                if (len < 4) {
	                    throw new RangeError('`e..eee` (weekday) patterns are not supported');
	                }
	                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
	                break;
	            case 'c':
	                if (len < 4) {
	                    throw new RangeError('`c..ccc` (weekday) patterns are not supported');
	                }
	                result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];
	                break;
	            // Period
	            case 'a': // AM, PM
	                result.hour12 = true;
	                break;
	            case 'b': // am, pm, noon, midnight
	            case 'B': // flexible day periods
	                throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');
	            // Hour
	            case 'h':
	                result.hourCycle = 'h12';
	                result.hour = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'H':
	                result.hourCycle = 'h23';
	                result.hour = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'K':
	                result.hourCycle = 'h11';
	                result.hour = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'k':
	                result.hourCycle = 'h24';
	                result.hour = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'j':
	            case 'J':
	            case 'C':
	                throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');
	            // Minute
	            case 'm':
	                result.minute = ['numeric', '2-digit'][len - 1];
	                break;
	            // Second
	            case 's':
	                result.second = ['numeric', '2-digit'][len - 1];
	                break;
	            case 'S':
	            case 'A':
	                throw new RangeError('`S/A` (second) pattenrs are not supported, use `s` instead');
	            // Zone
	            case 'z': // 1..3, 4: specific non-location format
	                result.timeZoneName = len < 4 ? 'short' : 'long';
	                break;
	            case 'Z': // 1..3, 4, 5: The ISO8601 varios formats
	            case 'O': // 1, 4: miliseconds in day short, long
	            case 'v': // 1, 4: generic non-location format
	            case 'V': // 1, 2, 3, 4: time zone ID or city
	            case 'X': // 1, 2, 3, 4: The ISO8601 varios formats
	            case 'x': // 1, 2, 3, 4: The ISO8601 varios formats
	                throw new RangeError('`Z/O/v/V/X/x` (timeZone) pattenrs are not supported, use `z` instead');
	        }
	        return '';
	    });
	    return result;
	}
	exports.parseDateTimeSkeleton = parseDateTimeSkeleton;
	function icuUnitToEcma(unit) {
	    return unit.replace(/^(.*?)-/, '');
	}
	var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g;
	var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?$/g;
	function parseSignificantPrecision(str) {
	    var result = {};
	    str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {
	        // @@@ case
	        if (typeof g2 !== 'string') {
	            result.minimumSignificantDigits = g1.length;
	            result.maximumSignificantDigits = g1.length;
	        }
	        // @@@+ case
	        else if (g2 === '+') {
	            result.minimumSignificantDigits = g1.length;
	        }
	        // .### case
	        else if (g1[0] === '#') {
	            result.maximumSignificantDigits = g1.length;
	        }
	        // .@@## or .@@@ case
	        else {
	            result.minimumSignificantDigits = g1.length;
	            result.maximumSignificantDigits =
	                g1.length + (typeof g2 === 'string' ? g2.length : 0);
	        }
	        return '';
	    });
	    return result;
	}
	function parseSign(str) {
	    switch (str) {
	        case 'sign-auto':
	            return {
	                signDisplay: 'auto',
	            };
	        case 'sign-accounting':
	            return {
	                currencySign: 'accounting',
	            };
	        case 'sign-always':
	            return {
	                signDisplay: 'always',
	            };
	        case 'sign-accounting-always':
	            return {
	                signDisplay: 'always',
	                currencySign: 'accounting',
	            };
	        case 'sign-except-zero':
	            return {
	                signDisplay: 'exceptZero',
	            };
	        case 'sign-accounting-except-zero':
	            return {
	                signDisplay: 'exceptZero',
	                currencySign: 'accounting',
	            };
	        case 'sign-never':
	            return {
	                signDisplay: 'never',
	            };
	    }
	}
	function parseNotationOptions(opt) {
	    var result = {};
	    var signOpts = parseSign(opt);
	    if (signOpts) {
	        return signOpts;
	    }
	    return result;
	}
	/**
	 * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options
	 */
	function convertNumberSkeletonToNumberFormatOptions(tokens) {
	    var result = {};
	    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
	        var token = tokens_1[_i];
	        switch (token.stem) {
	            case 'percent':
	                result.style = 'percent';
	                continue;
	            case 'currency':
	                result.style = 'currency';
	                result.currency = token.options[0];
	                continue;
	            case 'group-off':
	                result.useGrouping = false;
	                continue;
	            case 'precision-integer':
	            case '.':
	                result.maximumFractionDigits = 0;
	                continue;
	            case 'measure-unit':
	                result.style = 'unit';
	                result.unit = icuUnitToEcma(token.options[0]);
	                continue;
	            case 'compact-short':
	                result.notation = 'compact';
	                result.compactDisplay = 'short';
	                continue;
	            case 'compact-long':
	                result.notation = 'compact';
	                result.compactDisplay = 'long';
	                continue;
	            case 'scientific':
	                result = __assign(__assign(__assign({}, result), { notation: 'scientific' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
	                continue;
	            case 'engineering':
	                result = __assign(__assign(__assign({}, result), { notation: 'engineering' }), token.options.reduce(function (all, opt) { return (__assign(__assign({}, all), parseNotationOptions(opt))); }, {}));
	                continue;
	            case 'notation-simple':
	                result.notation = 'standard';
	                continue;
	            // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h
	            case 'unit-width-narrow':
	                result.currencyDisplay = 'narrowSymbol';
	                result.unitDisplay = 'narrow';
	                continue;
	            case 'unit-width-short':
	                result.currencyDisplay = 'code';
	                result.unitDisplay = 'short';
	                continue;
	            case 'unit-width-full-name':
	                result.currencyDisplay = 'name';
	                result.unitDisplay = 'long';
	                continue;
	            case 'unit-width-iso-code':
	                result.currencyDisplay = 'symbol';
	                continue;
	        }
	        // Precision
	        // https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#fraction-precision
	        // precision-integer case
	        if (FRACTION_PRECISION_REGEX.test(token.stem)) {
	            if (token.options.length > 1) {
	                throw new RangeError('Fraction-precision stems only accept a single optional option');
	            }
	            token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {
	                // .000* case (before ICU67 it was .000+)
	                if (g2 === '*') {
	                    result.minimumFractionDigits = g1.length;
	                }
	                // .### case
	                else if (g3 && g3[0] === '#') {
	                    result.maximumFractionDigits = g3.length;
	                }
	                // .00## case
	                else if (g4 && g5) {
	                    result.minimumFractionDigits = g4.length;
	                    result.maximumFractionDigits = g4.length + g5.length;
	                }
	                else {
	                    result.minimumFractionDigits = g1.length;
	                    result.maximumFractionDigits = g1.length;
	                }
	                return '';
	            });
	            if (token.options.length) {
	                result = __assign(__assign({}, result), parseSignificantPrecision(token.options[0]));
	            }
	            continue;
	        }
	        if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
	            result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));
	            continue;
	        }
	        var signOpts = parseSign(token.stem);
	        if (signOpts) {
	            result = __assign(__assign({}, result), signOpts);
	        }
	    }
	    return result;
	}
	exports.convertNumberSkeletonToNumberFormatOptions = convertNumberSkeletonToNumberFormatOptions;
	});

	var dummy = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(types);
	__export(skeleton);
	function parse() {
	    throw new Error("You're trying to format an uncompiled message with react-intl without parser, please import from 'react-int' instead");
	}
	exports.parse = parse;
	});

	//
	// Main
	//

	function memoize (fn, options) {
	  var cache = options && options.cache
	    ? options.cache
	    : cacheDefault;

	  var serializer = options && options.serializer
	    ? options.serializer
	    : serializerDefault;

	  var strategy = options && options.strategy
	    ? options.strategy
	    : strategyDefault;

	  return strategy(fn, {
	    cache: cache,
	    serializer: serializer
	  })
	}

	//
	// Strategy
	//

	function isPrimitive (value) {
	  return value == null || typeof value === 'number' || typeof value === 'boolean' // || typeof value === "string" 'unsafe' primitive for our needs
	}

	function monadic (fn, cache, serializer, arg) {
	  var cacheKey = isPrimitive(arg) ? arg : serializer(arg);

	  var computedValue = cache.get(cacheKey);
	  if (typeof computedValue === 'undefined') {
	    computedValue = fn.call(this, arg);
	    cache.set(cacheKey, computedValue);
	  }

	  return computedValue
	}

	function variadic (fn, cache, serializer) {
	  var args = Array.prototype.slice.call(arguments, 3);
	  var cacheKey = serializer(args);

	  var computedValue = cache.get(cacheKey);
	  if (typeof computedValue === 'undefined') {
	    computedValue = fn.apply(this, args);
	    cache.set(cacheKey, computedValue);
	  }

	  return computedValue
	}

	function assemble (fn, context, strategy, cache, serialize) {
	  return strategy.bind(
	    context,
	    fn,
	    cache,
	    serialize
	  )
	}

	function strategyDefault (fn, options) {
	  var strategy = fn.length === 1 ? monadic : variadic;

	  return assemble(
	    fn,
	    this,
	    strategy,
	    options.cache.create(),
	    options.serializer
	  )
	}

	function strategyVariadic (fn, options) {
	  var strategy = variadic;

	  return assemble(
	    fn,
	    this,
	    strategy,
	    options.cache.create(),
	    options.serializer
	  )
	}

	function strategyMonadic (fn, options) {
	  var strategy = monadic;

	  return assemble(
	    fn,
	    this,
	    strategy,
	    options.cache.create(),
	    options.serializer
	  )
	}

	//
	// Serializer
	//

	function serializerDefault () {
	  return JSON.stringify(arguments)
	}

	//
	// Cache
	//

	function ObjectWithoutPrototypeCache () {
	  this.cache = Object.create(null);
	}

	ObjectWithoutPrototypeCache.prototype.has = function (key) {
	  return (key in this.cache)
	};

	ObjectWithoutPrototypeCache.prototype.get = function (key) {
	  return this.cache[key]
	};

	ObjectWithoutPrototypeCache.prototype.set = function (key, value) {
	  this.cache[key] = value;
	};

	var cacheDefault = {
	  create: function create () {
	    return new ObjectWithoutPrototypeCache()
	  }
	};

	//
	// API
	//

	var src = memoize;
	var strategies = {
	  variadic: strategyVariadic,
	  monadic: strategyMonadic
	};
	src.strategies = strategies;

	var memoize$1 = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), src, {
		'default': src,
		strategies: strategies
	}));

	var error = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorCode;
	(function (ErrorCode) {
	    // When we have a placeholder but no value to format
	    ErrorCode["MISSING_VALUE"] = "MISSING_VALUE";
	    // When value supplied is invalid
	    ErrorCode["INVALID_VALUE"] = "INVALID_VALUE";
	    // When we need specific Intl API but it's not available
	    ErrorCode["MISSING_INTL_API"] = "MISSING_INTL_API";
	})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
	var FormatError = /** @class */ (function (_super) {
	    __extends(FormatError, _super);
	    function FormatError(msg, code, originalMessage) {
	        var _this = _super.call(this, msg) || this;
	        _this.code = code;
	        _this.originalMessage = originalMessage;
	        return _this;
	    }
	    FormatError.prototype.toString = function () {
	        return "[formatjs Error: " + this.code + "] " + this.message;
	    };
	    return FormatError;
	}(Error));
	exports.FormatError = FormatError;
	var InvalidValueError = /** @class */ (function (_super) {
	    __extends(InvalidValueError, _super);
	    function InvalidValueError(variableId, value, options, originalMessage) {
	        return _super.call(this, "Invalid values for \"" + variableId + "\": \"" + value + "\". Options are \"" + Object.keys(options).join('", "') + "\"", "INVALID_VALUE" /* INVALID_VALUE */, originalMessage) || this;
	    }
	    return InvalidValueError;
	}(FormatError));
	exports.InvalidValueError = InvalidValueError;
	var InvalidValueTypeError = /** @class */ (function (_super) {
	    __extends(InvalidValueTypeError, _super);
	    function InvalidValueTypeError(value, type, originalMessage) {
	        return _super.call(this, "Value for \"" + value + "\" must be of type " + type, "INVALID_VALUE" /* INVALID_VALUE */, originalMessage) || this;
	    }
	    return InvalidValueTypeError;
	}(FormatError));
	exports.InvalidValueTypeError = InvalidValueTypeError;
	var MissingValueError = /** @class */ (function (_super) {
	    __extends(MissingValueError, _super);
	    function MissingValueError(variableId, originalMessage) {
	        return _super.call(this, "The intl string context variable \"" + variableId + "\" was not provided to the string \"" + originalMessage + "\"", "MISSING_VALUE" /* MISSING_VALUE */, originalMessage) || this;
	    }
	    return MissingValueError;
	}(FormatError));
	exports.MissingValueError = MissingValueError;
	});

	var formatters = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	var PART_TYPE;
	(function (PART_TYPE) {
	    PART_TYPE[PART_TYPE["literal"] = 0] = "literal";
	    PART_TYPE[PART_TYPE["object"] = 1] = "object";
	})(PART_TYPE = exports.PART_TYPE || (exports.PART_TYPE = {}));
	function mergeLiteral(parts) {
	    if (parts.length < 2) {
	        return parts;
	    }
	    return parts.reduce(function (all, part) {
	        var lastPart = all[all.length - 1];
	        if (!lastPart ||
	            lastPart.type !== 0 /* literal */ ||
	            part.type !== 0 /* literal */) {
	            all.push(part);
	        }
	        else {
	            lastPart.value += part.value;
	        }
	        return all;
	    }, []);
	}
	function isFormatXMLElementFn(el) {
	    return typeof el === 'function';
	}
	exports.isFormatXMLElementFn = isFormatXMLElementFn;
	// TODO(skeleton): add skeleton support
	function formatToParts(els, locales, formatters, formats, values, currentPluralValue, 
	// For debugging
	originalMessage) {
	    // Hot path for straight simple msg translations
	    if (els.length === 1 && dummy.isLiteralElement(els[0])) {
	        return [
	            {
	                type: 0 /* literal */,
	                value: els[0].value,
	            },
	        ];
	    }
	    var result = [];
	    for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
	        var el = els_1[_i];
	        // Exit early for string parts.
	        if (dummy.isLiteralElement(el)) {
	            result.push({
	                type: 0 /* literal */,
	                value: el.value,
	            });
	            continue;
	        }
	        // TODO: should this part be literal type?
	        // Replace `#` in plural rules with the actual numeric value.
	        if (dummy.isPoundElement(el)) {
	            if (typeof currentPluralValue === 'number') {
	                result.push({
	                    type: 0 /* literal */,
	                    value: formatters.getNumberFormat(locales).format(currentPluralValue),
	                });
	            }
	            continue;
	        }
	        var varName = el.value;
	        // Enforce that all required values are provided by the caller.
	        if (!(values && varName in values)) {
	            throw new error.MissingValueError(varName, originalMessage);
	        }
	        var value = values[varName];
	        if (dummy.isArgumentElement(el)) {
	            if (!value || typeof value === 'string' || typeof value === 'number') {
	                value =
	                    typeof value === 'string' || typeof value === 'number'
	                        ? String(value)
	                        : '';
	            }
	            result.push({
	                type: typeof value === 'string' ? 0 /* literal */ : 1 /* object */,
	                value: value,
	            });
	            continue;
	        }
	        // Recursively format plural and select parts' option — which can be a
	        // nested pattern structure. The choosing of the option to use is
	        // abstracted-by and delegated-to the part helper object.
	        if (dummy.isDateElement(el)) {
	            var style = typeof el.style === 'string'
	                ? formats.date[el.style]
	                : dummy.isDateTimeSkeleton(el.style)
	                    ? dummy.parseDateTimeSkeleton(el.style.pattern)
	                    : undefined;
	            result.push({
	                type: 0 /* literal */,
	                value: formatters
	                    .getDateTimeFormat(locales, style)
	                    .format(value),
	            });
	            continue;
	        }
	        if (dummy.isTimeElement(el)) {
	            var style = typeof el.style === 'string'
	                ? formats.time[el.style]
	                : dummy.isDateTimeSkeleton(el.style)
	                    ? dummy.parseDateTimeSkeleton(el.style.pattern)
	                    : undefined;
	            result.push({
	                type: 0 /* literal */,
	                value: formatters
	                    .getDateTimeFormat(locales, style)
	                    .format(value),
	            });
	            continue;
	        }
	        if (dummy.isNumberElement(el)) {
	            var style = typeof el.style === 'string'
	                ? formats.number[el.style]
	                : dummy.isNumberSkeleton(el.style)
	                    ? dummy.convertNumberSkeletonToNumberFormatOptions(el.style.tokens)
	                    : undefined;
	            result.push({
	                type: 0 /* literal */,
	                value: formatters
	                    .getNumberFormat(locales, style)
	                    .format(value),
	            });
	            continue;
	        }
	        if (dummy.isTagElement(el)) {
	            var children = el.children, value_1 = el.value;
	            var formatFn = values[value_1];
	            if (!isFormatXMLElementFn(formatFn)) {
	                throw new error.InvalidValueTypeError(value_1, 'function', originalMessage);
	            }
	            var parts = formatToParts(children, locales, formatters, formats, values, currentPluralValue);
	            var chunks = formatFn(parts.map(function (p) { return p.value; }));
	            if (!Array.isArray(chunks)) {
	                chunks = [chunks];
	            }
	            result.push.apply(result, chunks.map(function (c) {
	                return {
	                    type: typeof c === 'string' ? 0 /* literal */ : 1 /* object */,
	                    value: c,
	                };
	            }));
	        }
	        if (dummy.isSelectElement(el)) {
	            var opt = el.options[value] || el.options.other;
	            if (!opt) {
	                throw new error.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
	            }
	            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
	            continue;
	        }
	        if (dummy.isPluralElement(el)) {
	            var opt = el.options["=" + value];
	            if (!opt) {
	                if (!Intl.PluralRules) {
	                    throw new error.FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */, originalMessage);
	                }
	                var rule = formatters
	                    .getPluralRules(locales, { type: el.pluralType })
	                    .select(value - (el.offset || 0));
	                opt = el.options[rule] || el.options.other;
	            }
	            if (!opt) {
	                throw new error.InvalidValueError(el.value, value, Object.keys(el.options), originalMessage);
	            }
	            result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
	            continue;
	        }
	    }
	    return mergeLiteral(result);
	}
	exports.formatToParts = formatToParts;
	});

	var core = createCommonjsModule(function (module, exports) {
	/*
	Copyright (c) 2014, Yahoo! Inc. All rights reserved.
	Copyrights licensed under the New BSD License.
	See the accompanying LICENSE file for terms.
	*/
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	};
	Object.defineProperty(exports, "__esModule", { value: true });



	// -- MessageFormat --------------------------------------------------------
	function mergeConfig(c1, c2) {
	    if (!c2) {
	        return c1;
	    }
	    return __assign(__assign(__assign({}, (c1 || {})), (c2 || {})), Object.keys(c1).reduce(function (all, k) {
	        all[k] = __assign(__assign({}, c1[k]), (c2[k] || {}));
	        return all;
	    }, {}));
	}
	function mergeConfigs(defaultConfig, configs) {
	    if (!configs) {
	        return defaultConfig;
	    }
	    return Object.keys(defaultConfig).reduce(function (all, k) {
	        all[k] = mergeConfig(defaultConfig[k], configs[k]);
	        return all;
	    }, __assign({}, defaultConfig));
	}
	function createFastMemoizeCache(store) {
	    return {
	        create: function () {
	            return {
	                has: function (key) {
	                    return key in store;
	                },
	                get: function (key) {
	                    return store[key];
	                },
	                set: function (key, value) {
	                    store[key] = value;
	                },
	            };
	        },
	    };
	}
	// @ts-ignore this is to deal with rollup's default import shenanigans
	var _memoizeIntl = src.default || src;
	var memoizeIntl = _memoizeIntl;
	function createDefaultFormatters(cache) {
	    if (cache === void 0) { cache = {
	        number: {},
	        dateTime: {},
	        pluralRules: {},
	    }; }
	    return {
	        getNumberFormat: memoizeIntl(function () {
	            var _a;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.number),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	        getDateTimeFormat: memoizeIntl(function () {
	            var _a;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.dateTime),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	        getPluralRules: memoizeIntl(function () {
	            var _a;
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.pluralRules),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	    };
	}
	var IntlMessageFormat = /** @class */ (function () {
	    function IntlMessageFormat(message, locales, overrideFormats, opts) {
	        var _this = this;
	        if (locales === void 0) { locales = IntlMessageFormat.defaultLocale; }
	        this.formatterCache = {
	            number: {},
	            dateTime: {},
	            pluralRules: {},
	        };
	        this.format = function (values) {
	            var parts = _this.formatToParts(values);
	            // Hot path for straight simple msg translations
	            if (parts.length === 1) {
	                return parts[0].value;
	            }
	            var result = parts.reduce(function (all, part) {
	                if (!all.length ||
	                    part.type !== 0 /* literal */ ||
	                    typeof all[all.length - 1] !== 'string') {
	                    all.push(part.value);
	                }
	                else {
	                    all[all.length - 1] += part.value;
	                }
	                return all;
	            }, []);
	            if (result.length <= 1) {
	                return result[0] || '';
	            }
	            return result;
	        };
	        this.formatToParts = function (values) {
	            return formatters.formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, undefined, _this.message);
	        };
	        this.resolvedOptions = function () { return ({
	            locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0],
	        }); };
	        this.getAst = function () { return _this.ast; };
	        if (typeof message === 'string') {
	            this.message = message;
	            if (!IntlMessageFormat.__parse) {
	                throw new TypeError('IntlMessageFormat.__parse must be set to process `message` of type `string`');
	            }
	            // Parse string messages into an AST.
	            this.ast = IntlMessageFormat.__parse(message, {
	                normalizeHashtagInPlural: false,
	                ignoreTag: opts === null || opts === void 0 ? void 0 : opts.ignoreTag,
	            });
	        }
	        else {
	            this.ast = message;
	        }
	        if (!Array.isArray(this.ast)) {
	            throw new TypeError('A message must be provided as a String or AST.');
	        }
	        // Creates a new object with the specified `formats` merged with the default
	        // formats.
	        this.formats = mergeConfigs(IntlMessageFormat.formats, overrideFormats);
	        // Defined first because it's used to build the format pattern.
	        this.locales = locales;
	        this.formatters =
	            (opts && opts.formatters) || createDefaultFormatters(this.formatterCache);
	    }
	    Object.defineProperty(IntlMessageFormat, "defaultLocale", {
	        get: function () {
	            if (!IntlMessageFormat.memoizedDefaultLocale) {
	                IntlMessageFormat.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
	            }
	            return IntlMessageFormat.memoizedDefaultLocale;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    IntlMessageFormat.memoizedDefaultLocale = null;
	    IntlMessageFormat.__parse = dummy.parse;
	    // Default format options used as the prototype of the `formats` provided to the
	    // constructor. These are used when constructing the internal Intl.NumberFormat
	    // and Intl.DateTimeFormat instances.
	    IntlMessageFormat.formats = {
	        number: {
	            currency: {
	                style: 'currency',
	            },
	            percent: {
	                style: 'percent',
	            },
	        },
	        date: {
	            short: {
	                month: 'numeric',
	                day: 'numeric',
	                year: '2-digit',
	            },
	            medium: {
	                month: 'short',
	                day: 'numeric',
	                year: 'numeric',
	            },
	            long: {
	                month: 'long',
	                day: 'numeric',
	                year: 'numeric',
	            },
	            full: {
	                weekday: 'long',
	                month: 'long',
	                day: 'numeric',
	                year: 'numeric',
	            },
	        },
	        time: {
	            short: {
	                hour: 'numeric',
	                minute: 'numeric',
	            },
	            medium: {
	                hour: 'numeric',
	                minute: 'numeric',
	                second: 'numeric',
	            },
	            long: {
	                hour: 'numeric',
	                minute: 'numeric',
	                second: 'numeric',
	                timeZoneName: 'short',
	            },
	            full: {
	                hour: 'numeric',
	                minute: 'numeric',
	                second: 'numeric',
	                timeZoneName: 'short',
	            },
	        },
	    };
	    return IntlMessageFormat;
	}());
	exports.IntlMessageFormat = IntlMessageFormat;
	});

	var intlMessageformat = createCommonjsModule(function (module, exports) {
	/*
	Copyright (c) 2014, Yahoo! Inc. All rights reserved.
	Copyrights licensed under the New BSD License.
	See the accompanying LICENSE file for terms.
	*/
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });

	__export(formatters);
	__export(core);
	__export(error);
	exports.default = core.IntlMessageFormat;
	});

	var diff = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	var MS_PER_SECOND = 1e3;
	var SECS_PER_MIN = 60;
	var SECS_PER_HOUR = SECS_PER_MIN * 60;
	var SECS_PER_DAY = SECS_PER_HOUR * 24;
	var SECS_PER_WEEK = SECS_PER_DAY * 7;
	function selectUnit(from, to, thresholds) {
	    if (to === void 0) { to = Date.now(); }
	    if (thresholds === void 0) { thresholds = {}; }
	    var resolvedThresholds = __assign(__assign({}, exports.DEFAULT_THRESHOLDS), (thresholds || {}));
	    var secs = (+from - +to) / MS_PER_SECOND;
	    if (Math.abs(secs) < resolvedThresholds.second) {
	        return {
	            value: Math.round(secs),
	            unit: 'second',
	        };
	    }
	    var mins = secs / SECS_PER_MIN;
	    if (Math.abs(mins) < resolvedThresholds.minute) {
	        return {
	            value: Math.round(mins),
	            unit: 'minute',
	        };
	    }
	    var hours = secs / SECS_PER_HOUR;
	    if (Math.abs(hours) < resolvedThresholds.hour) {
	        return {
	            value: Math.round(hours),
	            unit: 'hour',
	        };
	    }
	    var days = secs / SECS_PER_DAY;
	    if (Math.abs(days) < resolvedThresholds.day) {
	        return {
	            value: Math.round(days),
	            unit: 'day',
	        };
	    }
	    var fromDate = new Date(from);
	    var toDate = new Date(to);
	    var years = fromDate.getFullYear() - toDate.getFullYear();
	    if (Math.round(Math.abs(years)) > 0) {
	        return {
	            value: Math.round(years),
	            unit: 'year',
	        };
	    }
	    var months = years * 12 + fromDate.getMonth() - toDate.getMonth();
	    if (Math.round(Math.abs(months)) > 0) {
	        return {
	            value: Math.round(months),
	            unit: 'month',
	        };
	    }
	    var weeks = secs / SECS_PER_WEEK;
	    return {
	        value: Math.round(weeks),
	        unit: 'week',
	    };
	}
	exports.selectUnit = selectUnit;
	exports.DEFAULT_THRESHOLDS = {
	    second: 45,
	    minute: 45,
	    hour: 22,
	    day: 5,
	};
	});

	var invariant_1 = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	function invariant(condition, message, Err) {
	    if (Err === void 0) { Err = Error; }
	    if (!condition) {
	        throw new Err(message);
	    }
	}
	exports.invariant = invariant;
	});

	var units = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	// https://tc39.es/ecma402/#sec-issanctionedsimpleunitidentifier
	exports.SANCTIONED_UNITS = [
	    'angle-degree',
	    'area-acre',
	    'area-hectare',
	    'concentr-percent',
	    'digital-bit',
	    'digital-byte',
	    'digital-gigabit',
	    'digital-gigabyte',
	    'digital-kilobit',
	    'digital-kilobyte',
	    'digital-megabit',
	    'digital-megabyte',
	    'digital-petabyte',
	    'digital-terabit',
	    'digital-terabyte',
	    'duration-day',
	    'duration-hour',
	    'duration-millisecond',
	    'duration-minute',
	    'duration-month',
	    'duration-second',
	    'duration-week',
	    'duration-year',
	    'length-centimeter',
	    'length-foot',
	    'length-inch',
	    'length-kilometer',
	    'length-meter',
	    'length-mile-scandinavian',
	    'length-mile',
	    'length-millimeter',
	    'length-yard',
	    'mass-gram',
	    'mass-kilogram',
	    'mass-ounce',
	    'mass-pound',
	    'mass-stone',
	    'temperature-celsius',
	    'temperature-fahrenheit',
	    'volume-fluid-ounce',
	    'volume-gallon',
	    'volume-liter',
	    'volume-milliliter',
	];
	// In CLDR, the unit name always follows the form `namespace-unit` pattern.
	// For example: `digital-bit` instead of `bit`. This function removes the namespace prefix.
	function removeUnitNamespace(unit) {
	    return unit.replace(/^(.*?)-/, '');
	}
	exports.removeUnitNamespace = removeUnitNamespace;
	});

	var polyfillUtils = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	function hasOwnProperty(o, key) {
	    return Object.prototype.hasOwnProperty.call(o, key);
	}
	exports.hasOwnProperty = hasOwnProperty;
	/**
	 * https://tc39.es/ecma262/#sec-toobject
	 * @param arg
	 */
	function toObject(arg) {
	    if (arg == null) {
	        throw new TypeError('undefined/null cannot be converted to object');
	    }
	    return Object(arg);
	}
	exports.toObject = toObject;
	/**
	 * https://tc39.es/ecma262/#sec-tostring
	 */
	function toString(o) {
	    // Only symbol is irregular...
	    if (typeof o === 'symbol') {
	        throw TypeError('Cannot convert a Symbol value to a string');
	    }
	    return String(o);
	}
	exports.toString = toString;
	/**
	 * https://tc39.es/ecma402/#sec-getoption
	 * @param opts
	 * @param prop
	 * @param type
	 * @param values
	 * @param fallback
	 */
	function getOption(opts, prop, type, values, fallback) {
	    // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
	    var value = opts[prop];
	    if (value !== undefined) {
	        if (type !== 'boolean' && type !== 'string') {
	            throw new TypeError('invalid type');
	        }
	        if (type === 'boolean') {
	            value = Boolean(value);
	        }
	        if (type === 'string') {
	            value = toString(value);
	        }
	        if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
	            throw new RangeError(value + " is not within " + values.join(', '));
	        }
	        return value;
	    }
	    return fallback;
	}
	exports.getOption = getOption;
	/**
	 * https://tc39.es/ecma402/#sec-defaultnumberoption
	 * @param val
	 * @param min
	 * @param max
	 * @param fallback
	 */
	function defaultNumberOption(val, min, max, fallback) {
	    if (val !== undefined) {
	        val = Number(val);
	        if (isNaN(val) || val < min || val > max) {
	            throw new RangeError(val + " is outside of range [" + min + ", " + max + "]");
	        }
	        return Math.floor(val);
	    }
	    return fallback;
	}
	exports.defaultNumberOption = defaultNumberOption;
	/**
	 * https://tc39.es/ecma402/#sec-getnumberoption
	 * @param options
	 * @param property
	 * @param min
	 * @param max
	 * @param fallback
	 */
	function getNumberOption(options, property, minimum, maximum, fallback) {
	    var val = options[property];
	    return defaultNumberOption(val, minimum, maximum, fallback);
	}
	exports.getNumberOption = getNumberOption;
	function setInternalSlot(map, pl, field, value) {
	    if (!map.get(pl)) {
	        map.set(pl, Object.create(null));
	    }
	    var slots = map.get(pl);
	    slots[field] = value;
	}
	exports.setInternalSlot = setInternalSlot;
	function setMultiInternalSlots(map, pl, props) {
	    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
	        var k = _a[_i];
	        setInternalSlot(map, pl, k, props[k]);
	    }
	}
	exports.setMultiInternalSlots = setMultiInternalSlots;
	function getInternalSlot(map, pl, field) {
	    return getMultiInternalSlots(map, pl, field)[field];
	}
	exports.getInternalSlot = getInternalSlot;
	function getMultiInternalSlots(map, pl) {
	    var fields = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        fields[_i - 2] = arguments[_i];
	    }
	    var slots = map.get(pl);
	    if (!slots) {
	        throw new TypeError(pl + " InternalSlot has not been initialized");
	    }
	    return fields.reduce(function (all, f) {
	        all[f] = slots[f];
	        return all;
	    }, Object.create(null));
	}
	exports.getMultiInternalSlots = getMultiInternalSlots;
	function isLiteralPart(patternPart) {
	    return patternPart.type === 'literal';
	}
	exports.isLiteralPart = isLiteralPart;
	function partitionPattern(pattern) {
	    var result = [];
	    var beginIndex = pattern.indexOf('{');
	    var endIndex = 0;
	    var nextIndex = 0;
	    var length = pattern.length;
	    while (beginIndex < pattern.length && beginIndex > -1) {
	        endIndex = pattern.indexOf('}', beginIndex);
	        invariant_1.invariant(endIndex > beginIndex, "Invalid pattern " + pattern);
	        if (beginIndex > nextIndex) {
	            result.push({
	                type: 'literal',
	                value: pattern.substring(nextIndex, beginIndex),
	            });
	        }
	        result.push({
	            type: pattern.substring(beginIndex + 1, endIndex),
	            value: undefined,
	        });
	        nextIndex = endIndex + 1;
	        beginIndex = pattern.indexOf('{', nextIndex);
	    }
	    if (nextIndex < length) {
	        result.push({
	            type: 'literal',
	            value: pattern.substring(nextIndex, length),
	        });
	    }
	    return result;
	}
	exports.partitionPattern = partitionPattern;
	/**
	 * https://tc39.es/ecma402/#sec-setnfdigitoptions
	 */
	function setNumberFormatDigitOptions(internalSlots, opts, mnfdDefault, mxfdDefault, notation) {
	    var mnid = getNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);
	    var mnfd = opts.minimumFractionDigits;
	    var mxfd = opts.maximumFractionDigits;
	    var mnsd = opts.minimumSignificantDigits;
	    var mxsd = opts.maximumSignificantDigits;
	    internalSlots.minimumIntegerDigits = mnid;
	    if (mnsd !== undefined || mxsd !== undefined) {
	        internalSlots.roundingType = 'significantDigits';
	        mnsd = defaultNumberOption(mnsd, 1, 21, 1);
	        mxsd = defaultNumberOption(mxsd, mnsd, 21, 21);
	        internalSlots.minimumSignificantDigits = mnsd;
	        internalSlots.maximumSignificantDigits = mxsd;
	    }
	    else if (mnfd !== undefined || mxfd !== undefined) {
	        internalSlots.roundingType = 'fractionDigits';
	        mnfd = defaultNumberOption(mnfd, 0, 20, mnfdDefault);
	        var mxfdActualDefault = Math.max(mnfd, mxfdDefault);
	        mxfd = defaultNumberOption(mxfd, mnfd, 20, mxfdActualDefault);
	        internalSlots.minimumFractionDigits = mnfd;
	        internalSlots.maximumFractionDigits = mxfd;
	    }
	    else if (notation === 'compact') {
	        internalSlots.roundingType = 'compactRounding';
	    }
	    else {
	        internalSlots.roundingType = 'fractionDigits';
	        internalSlots.minimumFractionDigits = mnfdDefault;
	        internalSlots.maximumFractionDigits = mxfdDefault;
	    }
	}
	exports.setNumberFormatDigitOptions = setNumberFormatDigitOptions;
	function objectIs(x, y) {
	    if (Object.is) {
	        return Object.is(x, y);
	    }
	    // SameValue algorithm
	    if (x === y) {
	        // Steps 1-5, 7-10
	        // Steps 6.b-6.e: +0 != -0
	        return x !== 0 || 1 / x === 1 / y;
	    }
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	}
	exports.objectIs = objectIs;
	var NOT_A_Z_REGEX = /[^A-Z]/;
	/**
	 * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
	 * @param str string to convert
	 */
	function toUpperCase(str) {
	    return str.replace(/([a-z])/g, function (_, c) { return c.toUpperCase(); });
	}
	/**
	 * https://tc39.es/ecma402/#sec-iswellformedcurrencycode
	 */
	function isWellFormedCurrencyCode(currency) {
	    currency = toUpperCase(currency);
	    if (currency.length !== 3) {
	        return false;
	    }
	    if (NOT_A_Z_REGEX.test(currency)) {
	        return false;
	    }
	    return true;
	}
	exports.isWellFormedCurrencyCode = isWellFormedCurrencyCode;
	/**
	 * https://tc39.es/ecma402/#sec-formatnumberstring
	 * TODO: dedup with intl-pluralrules
	 */
	function formatNumericToString(internalSlots, x) {
	    var isNegative = x < 0 || objectIs(x, -0);
	    if (isNegative) {
	        x = -x;
	    }
	    var result;
	    var rourndingType = internalSlots.roundingType;
	    switch (rourndingType) {
	        case 'significantDigits':
	            result = toRawPrecision(x, internalSlots.minimumSignificantDigits, internalSlots.maximumSignificantDigits);
	            break;
	        case 'fractionDigits':
	            result = toRawFixed(x, internalSlots.minimumFractionDigits, internalSlots.maximumFractionDigits);
	            break;
	        default:
	            result = toRawPrecision(x, 1, 2);
	            if (result.integerDigitsCount > 1) {
	                result = toRawFixed(x, 0, 0);
	            }
	            break;
	    }
	    x = result.roundedNumber;
	    var string = result.formattedString;
	    var int = result.integerDigitsCount;
	    var minInteger = internalSlots.minimumIntegerDigits;
	    if (int < minInteger) {
	        var forwardZeros = repeat('0', minInteger - int);
	        string = forwardZeros + string;
	    }
	    if (isNegative) {
	        x = -x;
	    }
	    return { roundedNumber: x, formattedString: string };
	}
	exports.formatNumericToString = formatNumericToString;
	/**
	 * TODO: dedup with intl-pluralrules and support BigInt
	 * https://tc39.es/ecma402/#sec-torawfixed
	 * @param x a finite non-negative Number or BigInt
	 * @param minFraction and integer between 0 and 20
	 * @param maxFraction and integer between 0 and 20
	 */
	function toRawFixed(x, minFraction, maxFraction) {
	    var f = maxFraction;
	    var n = Math.round(x * Math.pow(10, f));
	    var xFinal = n / Math.pow(10, f);
	    // n is a positive integer, but it is possible to be greater than 1e21.
	    // In such case we will go the slow path.
	    // See also: https://tc39.es/ecma262/#sec-numeric-types-number-tostring
	    var m;
	    if (n < 1e21) {
	        m = n.toString();
	    }
	    else {
	        m = n.toString();
	        var _a = m.split('e'), mantissa = _a[0], exponent = _a[1];
	        m = mantissa.replace('.', '');
	        m = m + repeat('0', Math.max(+exponent - m.length + 1, 0));
	    }
	    var int;
	    if (f !== 0) {
	        var k = m.length;
	        if (k <= f) {
	            var z = repeat('0', f + 1 - k);
	            m = z + m;
	            k = f + 1;
	        }
	        var a = m.slice(0, k - f);
	        var b = m.slice(k - f);
	        m = a + "." + b;
	        int = a.length;
	    }
	    else {
	        int = m.length;
	    }
	    var cut = maxFraction - minFraction;
	    while (cut > 0 && m[m.length - 1] === '0') {
	        m = m.slice(0, -1);
	        cut--;
	    }
	    if (m[m.length - 1] === '.') {
	        m = m.slice(0, -1);
	    }
	    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
	}
	exports.toRawFixed = toRawFixed;
	// https://tc39.es/ecma402/#sec-torawprecision
	function toRawPrecision(x, minPrecision, maxPrecision) {
	    var p = maxPrecision;
	    var m;
	    var e;
	    var xFinal;
	    if (x === 0) {
	        m = repeat('0', p);
	        e = 0;
	        xFinal = 0;
	    }
	    else {
	        var xToString = x.toString();
	        // If xToString is formatted as scientific notation, the number is either very small or very
	        // large. If the precision of the formatted string is lower that requested max precision, we
	        // should still infer them from the formatted string, otherwise the formatted result might have
	        // precision loss (e.g. 1e41 will not have 0 in every trailing digits).
	        var xToStringExponentIndex = xToString.indexOf('e');
	        var _a = xToString.split('e'), xToStringMantissa = _a[0], xToStringExponent = _a[1];
	        var xToStringMantissaWithoutDecimalPoint = xToStringMantissa.replace('.', '');
	        if (xToStringExponentIndex >= 0 &&
	            xToStringMantissaWithoutDecimalPoint.length <= p) {
	            e = +xToStringExponent;
	            m =
	                xToStringMantissaWithoutDecimalPoint +
	                    repeat('0', p - xToStringMantissaWithoutDecimalPoint.length);
	            xFinal = x;
	        }
	        else {
	            e = getMagnitude(x);
	            var decimalPlaceOffset = e - p + 1;
	            // n is the integer containing the required precision digits. To derive the formatted string,
	            // we will adjust its decimal place in the logic below.
	            var n = Math.round(adjustDecimalPlace(x, decimalPlaceOffset));
	            // The rounding caused the change of magnitude, so we should increment `e` by 1.
	            if (adjustDecimalPlace(n, p - 1) >= 10) {
	                e = e + 1;
	                // Divide n by 10 to swallow one precision.
	                n = Math.floor(n / 10);
	            }
	            m = n.toString();
	            // Equivalent of n * 10 ** (e - p + 1)
	            xFinal = adjustDecimalPlace(n, p - 1 - e);
	        }
	    }
	    var int;
	    if (e >= p - 1) {
	        m = m + repeat('0', e - p + 1);
	        int = e + 1;
	    }
	    else if (e >= 0) {
	        m = m.slice(0, e + 1) + "." + m.slice(e + 1);
	        int = e + 1;
	    }
	    else {
	        m = "0." + repeat('0', -e - 1) + m;
	        int = 1;
	    }
	    if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {
	        var cut = maxPrecision - minPrecision;
	        while (cut > 0 && m[m.length - 1] === '0') {
	            m = m.slice(0, -1);
	            cut--;
	        }
	        if (m[m.length - 1] === '.') {
	            m = m.slice(0, -1);
	        }
	    }
	    return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
	    // x / (10 ** magnitude), but try to preserve as much floating point precision as possible.
	    function adjustDecimalPlace(x, magnitude) {
	        return magnitude < 0 ? x * Math.pow(10, -magnitude) : x / Math.pow(10, magnitude);
	    }
	}
	exports.toRawPrecision = toRawPrecision;
	function repeat(s, times) {
	    if (typeof s.repeat === 'function') {
	        return s.repeat(times);
	    }
	    var arr = new Array(times);
	    for (var i = 0; i < arr.length; i++) {
	        arr[i] = s;
	    }
	    return arr.join('');
	}
	exports.repeat = repeat;
	/**
	 * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
	 * @param x number
	 */
	function getMagnitude(x) {
	    // Cannot count string length via Number.toString because it may use scientific notation
	    // for very small or very large numbers.
	    return Math.floor(Math.log(x) * Math.LOG10E);
	}
	exports.getMagnitude = getMagnitude;
	/**
	 * This follows https://tc39.es/ecma402/#sec-case-sensitivity-and-case-mapping
	 * @param str string to convert
	 */
	function toLowerCase(str) {
	    return str.replace(/([A-Z])/g, function (_, c) { return c.toLowerCase(); });
	}
	var SHORTENED_SACTION_UNITS = units.SANCTIONED_UNITS.map(function (unit) {
	    return unit.replace(/^(.*?)-/, '');
	});
	/**
	 * https://tc39.es/ecma402/#sec-iswellformedunitidentifier
	 * @param unit
	 */
	function isWellFormedUnitIdentifier(unit) {
	    unit = toLowerCase(unit);
	    if (SHORTENED_SACTION_UNITS.indexOf(unit) > -1) {
	        return true;
	    }
	    var units = unit.split('-per-');
	    if (units.length !== 2) {
	        return false;
	    }
	    if (SHORTENED_SACTION_UNITS.indexOf(units[0]) < 0 ||
	        SHORTENED_SACTION_UNITS.indexOf(units[1]) < 0) {
	        return false;
	    }
	    return true;
	}
	exports.isWellFormedUnitIdentifier = isWellFormedUnitIdentifier;
	/*
	  17 ECMAScript Standard Built-in Objects:
	    Every built-in Function object, including constructors, that is not
	    identified as an anonymous function has a name property whose value
	    is a String.

	    Unless otherwise specified, the name property of a built-in Function
	    object, if it exists, has the attributes { [[Writable]]: false,
	    [[Enumerable]]: false, [[Configurable]]: true }.
	*/
	function defineProperty(target, name, _a) {
	    var value = _a.value;
	    Object.defineProperty(target, name, {
	        configurable: true,
	        enumerable: false,
	        writable: true,
	        value: value,
	    });
	}
	exports.defineProperty = defineProperty;
	});

	var resolveLocale = createCommonjsModule(function (module, exports) {
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });


	function createResolveLocale(getDefaultLocale) {
	    var lookupMatcher = createLookupMatcher(getDefaultLocale);
	    var bestFitMatcher = createBestFitMatcher(getDefaultLocale);
	    /**
	     * https://tc39.es/ecma402/#sec-resolvelocale
	     */
	    return function resolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {
	        var matcher = options.localeMatcher;
	        var r;
	        if (matcher === 'lookup') {
	            r = lookupMatcher(availableLocales, requestedLocales);
	        }
	        else {
	            r = bestFitMatcher(availableLocales, requestedLocales);
	        }
	        var foundLocale = r.locale;
	        var result = { locale: '', dataLocale: foundLocale };
	        var supportedExtension = '-u';
	        for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
	            var key = relevantExtensionKeys_1[_i];
	            var foundLocaleData = localeData[foundLocale];
	            invariant_1.invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
	            var keyLocaleData = foundLocaleData[key];
	            invariant_1.invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
	            var value = keyLocaleData[0];
	            invariant_1.invariant(typeof value === 'string' || value === null, "value must be string or null but got " + typeof value + " in key " + key);
	            var supportedExtensionAddition = '';
	            if (r.extension) {
	                var requestedValue = unicodeExtensionValue(r.extension, key);
	                if (requestedValue !== undefined) {
	                    if (requestedValue !== '') {
	                        if (~keyLocaleData.indexOf(requestedValue)) {
	                            value = requestedValue;
	                            supportedExtensionAddition = "-" + key + "-" + value;
	                        }
	                    }
	                    else if (~requestedValue.indexOf('true')) {
	                        value = 'true';
	                        supportedExtensionAddition = "-" + key;
	                    }
	                }
	            }
	            if (key in options) {
	                var optionsValue = options[key];
	                invariant_1.invariant(typeof optionsValue === 'string' ||
	                    typeof optionsValue === 'undefined' ||
	                    optionsValue === null, 'optionsValue must be String, Undefined or Null');
	                if (~keyLocaleData.indexOf(optionsValue)) {
	                    if (optionsValue !== value) {
	                        value = optionsValue;
	                        supportedExtensionAddition = '';
	                    }
	                }
	            }
	            result[key] = value;
	            supportedExtension += supportedExtensionAddition;
	        }
	        if (supportedExtension.length > 2) {
	            var privateIndex = foundLocale.indexOf('-x-');
	            if (privateIndex === -1) {
	                foundLocale = foundLocale + supportedExtension;
	            }
	            else {
	                var preExtension = foundLocale.slice(0, privateIndex);
	                var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
	                foundLocale = preExtension + supportedExtension + postExtension;
	            }
	            foundLocale = Intl.getCanonicalLocales(foundLocale)[0];
	        }
	        result.locale = foundLocale;
	        return result;
	    };
	}
	exports.createResolveLocale = createResolveLocale;
	/**
	 * https://tc39.es/ecma402/#sec-unicodeextensionvalue
	 * @param extension
	 * @param key
	 */
	function unicodeExtensionValue(extension, key) {
	    invariant_1.invariant(key.length === 2, 'key must have 2 elements');
	    var size = extension.length;
	    var searchValue = "-" + key + "-";
	    var pos = extension.indexOf(searchValue);
	    if (pos !== -1) {
	        var start = pos + 4;
	        var end = start;
	        var k = start;
	        var done = false;
	        while (!done) {
	            var e = extension.indexOf('-', k);
	            var len = void 0;
	            if (e === -1) {
	                len = size - k;
	            }
	            else {
	                len = e - k;
	            }
	            if (len === 2) {
	                done = true;
	            }
	            else if (e === -1) {
	                end = size;
	                done = true;
	            }
	            else {
	                end = e;
	                k = e + 1;
	            }
	        }
	        return extension.slice(start, end);
	    }
	    searchValue = "-" + key;
	    pos = extension.indexOf(searchValue);
	    if (pos !== -1 && pos + 3 === size) {
	        return '';
	    }
	    return undefined;
	}
	var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
	/**
	 * https://tc39.es/ecma402/#sec-bestavailablelocale
	 * @param availableLocales
	 * @param locale
	 */
	function bestAvailableLocale(availableLocales, locale) {
	    var candidate = locale;
	    while (true) {
	        if (~availableLocales.indexOf(candidate)) {
	            return candidate;
	        }
	        var pos = candidate.lastIndexOf('-');
	        if (!~pos) {
	            return undefined;
	        }
	        if (pos >= 2 && candidate[pos - 2] === '-') {
	            pos -= 2;
	        }
	        candidate = candidate.slice(0, pos);
	    }
	}
	function createLookupMatcher(getDefaultLocale) {
	    /**
	     * https://tc39.es/ecma402/#sec-lookupmatcher
	     */
	    return function lookupMatcher(availableLocales, requestedLocales) {
	        var result = { locale: '' };
	        for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
	            var locale = requestedLocales_1[_i];
	            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	            var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
	            if (availableLocale) {
	                result.locale = availableLocale;
	                if (locale !== noExtensionLocale) {
	                    result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	                }
	                return result;
	            }
	        }
	        result.locale = getDefaultLocale();
	        return result;
	    };
	}
	function createBestFitMatcher(getDefaultLocale) {
	    return function bestFitMatcher(availableLocales, requestedLocales) {
	        var result = { locale: '' };
	        for (var _i = 0, requestedLocales_2 = requestedLocales; _i < requestedLocales_2.length; _i++) {
	            var locale = requestedLocales_2[_i];
	            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	            var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
	            if (availableLocale) {
	                result.locale = availableLocale;
	                if (locale !== noExtensionLocale) {
	                    result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
	                }
	                return result;
	            }
	        }
	        result.locale = getDefaultLocale();
	        return result;
	    };
	}
	function getLocaleHierarchy(locale) {
	    var results = [locale];
	    var localeParts = locale.split('-');
	    for (var i = localeParts.length; i > 1; i--) {
	        results.push(localeParts.slice(0, i - 1).join('-'));
	    }
	    return results;
	}
	exports.getLocaleHierarchy = getLocaleHierarchy;
	function lookupSupportedLocales(availableLocales, requestedLocales) {
	    var subset = [];
	    for (var _i = 0, requestedLocales_3 = requestedLocales; _i < requestedLocales_3.length; _i++) {
	        var locale = requestedLocales_3[_i];
	        var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
	        var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
	        if (availableLocale) {
	            subset.push(availableLocale);
	        }
	    }
	    return subset;
	}
	function supportedLocales(availableLocales, requestedLocales, options) {
	    var matcher = 'best fit';
	    if (options !== undefined) {
	        options = polyfillUtils.toObject(options);
	        matcher = polyfillUtils.getOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
	    }
	    if (matcher === 'best fit') {
	        return lookupSupportedLocales(availableLocales, requestedLocales);
	    }
	    return lookupSupportedLocales(availableLocales, requestedLocales);
	}
	exports.supportedLocales = supportedLocales;
	var MissingLocaleDataError = /** @class */ (function (_super) {
	    __extends(MissingLocaleDataError, _super);
	    function MissingLocaleDataError() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.type = 'MISSING_LOCALE_DATA';
	        return _this;
	    }
	    return MissingLocaleDataError;
	}(Error));
	function isMissingLocaleDataError(e) {
	    return e.type === 'MISSING_LOCALE_DATA';
	}
	exports.isMissingLocaleDataError = isMissingLocaleDataError;
	function unpackData(locale, localeData, 
	/** By default shallow merge the dictionaries. */
	reducer) {
	    if (reducer === void 0) { reducer = function (all, d) { return (__assign(__assign({}, all), d)); }; }
	    var localeHierarchy = getLocaleHierarchy(locale);
	    var dataToMerge = localeHierarchy
	        .map(function (l) { return localeData.data[l]; })
	        .filter(Boolean);
	    if (!dataToMerge.length) {
	        throw new MissingLocaleDataError("Missing locale data for \"" + locale + "\", lookup hierarchy: " + localeHierarchy.join(', '));
	    }
	    dataToMerge.reverse();
	    return dataToMerge.reduce(reducer, {});
	}
	exports.unpackData = unpackData;
	});

	var intlUtils = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });

	exports.selectUnit = diff.selectUnit;

	exports.defaultNumberOption = polyfillUtils.defaultNumberOption;
	exports.getInternalSlot = polyfillUtils.getInternalSlot;
	exports.getMultiInternalSlots = polyfillUtils.getMultiInternalSlots;
	exports.getNumberOption = polyfillUtils.getNumberOption;
	exports.getOption = polyfillUtils.getOption;
	exports.isLiteralPart = polyfillUtils.isLiteralPart;
	exports.partitionPattern = polyfillUtils.partitionPattern;
	exports.setInternalSlot = polyfillUtils.setInternalSlot;
	exports.setMultiInternalSlots = polyfillUtils.setMultiInternalSlots;
	exports.setNumberFormatDigitOptions = polyfillUtils.setNumberFormatDigitOptions;
	exports.toObject = polyfillUtils.toObject;
	exports.objectIs = polyfillUtils.objectIs;
	exports.isWellFormedCurrencyCode = polyfillUtils.isWellFormedCurrencyCode;
	exports.toString = polyfillUtils.toString;
	exports.formatNumericToString = polyfillUtils.formatNumericToString;
	exports.toRawFixed = polyfillUtils.toRawFixed;
	exports.toRawPrecision = polyfillUtils.toRawPrecision;
	exports.getMagnitude = polyfillUtils.getMagnitude;
	exports.repeat = polyfillUtils.repeat;
	exports.hasOwnProperty = polyfillUtils.hasOwnProperty;
	exports.isWellFormedUnitIdentifier = polyfillUtils.isWellFormedUnitIdentifier;
	exports.defineProperty = polyfillUtils.defineProperty;

	exports.createResolveLocale = resolveLocale.createResolveLocale;
	exports.getLocaleHierarchy = resolveLocale.getLocaleHierarchy;
	exports.supportedLocales = resolveLocale.supportedLocales;
	exports.unpackData = resolveLocale.unpackData;
	exports.isMissingLocaleDataError = resolveLocale.isMissingLocaleDataError;
	__export(units);

	exports.invariant = invariant_1.invariant;
	});

	var __extends = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	(function (ReactIntlErrorCode) {
	    ReactIntlErrorCode["FORMAT_ERROR"] = "FORMAT_ERROR";
	    ReactIntlErrorCode["UNSUPPORTED_FORMATTER"] = "UNSUPPORTED_FORMATTER";
	    ReactIntlErrorCode["INVALID_CONFIG"] = "INVALID_CONFIG";
	    ReactIntlErrorCode["MISSING_DATA"] = "MISSING_DATA";
	    ReactIntlErrorCode["MISSING_TRANSLATION"] = "MISSING_TRANSLATION";
	})(exports.ReactIntlErrorCode || (exports.ReactIntlErrorCode = {}));
	var ReactIntlError = /** @class */ (function (_super) {
	    __extends(ReactIntlError, _super);
	    function ReactIntlError(code, message, exception) {
	        var _this = _super.call(this, "[React Intl Error " + code + "] " + message + " \n" + (exception ? "\n" + exception.message + "\n" + exception.stack : '')) || this;
	        _this.code = code;
	        if (typeof Error.captureStackTrace === 'function') {
	            Error.captureStackTrace(_this, ReactIntlError);
	        }
	        return _this;
	    }
	    return ReactIntlError;
	}(Error));
	var UnsupportedFormatterError = /** @class */ (function (_super) {
	    __extends(UnsupportedFormatterError, _super);
	    function UnsupportedFormatterError(message, exception) {
	        return _super.call(this, "UNSUPPORTED_FORMATTER" /* UNSUPPORTED_FORMATTER */, message, exception) || this;
	    }
	    return UnsupportedFormatterError;
	}(ReactIntlError));
	var InvalidConfigError = /** @class */ (function (_super) {
	    __extends(InvalidConfigError, _super);
	    function InvalidConfigError(message, exception) {
	        return _super.call(this, "INVALID_CONFIG" /* INVALID_CONFIG */, message, exception) || this;
	    }
	    return InvalidConfigError;
	}(ReactIntlError));
	var MissingDataError = /** @class */ (function (_super) {
	    __extends(MissingDataError, _super);
	    function MissingDataError(message, exception) {
	        return _super.call(this, "MISSING_DATA" /* MISSING_DATA */, message, exception) || this;
	    }
	    return MissingDataError;
	}(ReactIntlError));
	var MessageFormatError = /** @class */ (function (_super) {
	    __extends(MessageFormatError, _super);
	    function MessageFormatError(message, locale, descriptor, exception) {
	        var _this = _super.call(this, "FORMAT_ERROR" /* FORMAT_ERROR */, message + " \nLocale: " + locale + "\nMessageID: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.id) + "\nDefault Message: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.defaultMessage) + "\nDescription: " + (descriptor === null || descriptor === void 0 ? void 0 : descriptor.description) + " \n", exception) || this;
	        _this.descriptor = descriptor;
	        return _this;
	    }
	    return MessageFormatError;
	}(ReactIntlError));
	var MissingTranslationError = /** @class */ (function (_super) {
	    __extends(MissingTranslationError, _super);
	    function MissingTranslationError(descriptor, locale) {
	        var _this = _super.call(this, "MISSING_TRANSLATION" /* MISSING_TRANSLATION */, "Missing message: \"" + descriptor.id + "\" for locale \"" + locale + "\", using " + (descriptor.defaultMessage ? 'default message' : 'id') + " as fallback.") || this;
	        _this.descriptor = descriptor;
	        return _this;
	    }
	    return MissingTranslationError;
	}(ReactIntlError));

	/*
	HTML escaping is the same as React's
	(on purpose.) Therefore, it has the following Copyright and Licensing:

	Copyright 2013-2014, Facebook, Inc.
	All rights reserved.

	This source code is licensed under the BSD-style license found in the LICENSE
	file in the root directory of React's source tree.
	*/
	var __assign = (undefined && undefined.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	};
	function filterProps(props, whitelist, defaults) {
	    if (defaults === void 0) { defaults = {}; }
	    return whitelist.reduce(function (filtered, name) {
	        if (name in props) {
	            filtered[name] = props[name];
	        }
	        else if (name in defaults) {
	            filtered[name] = defaults[name];
	        }
	        return filtered;
	    }, {});
	}
	function invariantIntlContext(intl) {
	    intlUtils.invariant(intl, '[React Intl] Could not find required `intl` object. ' +
	        '<IntlProvider> needs to exist in the component ancestry.');
	}
	var defaultErrorHandler = function (error) {
	};
	var DEFAULT_INTL_CONFIG = {
	    formats: {},
	    messages: {},
	    timeZone: undefined,
	    textComponent: React.Fragment,
	    defaultLocale: 'en',
	    defaultFormats: {},
	    onError: defaultErrorHandler,
	};
	function createIntlCache() {
	    return {
	        dateTime: {},
	        number: {},
	        message: {},
	        relativeTime: {},
	        pluralRules: {},
	        list: {},
	        displayNames: {},
	    };
	}
	function createFastMemoizeCache(store) {
	    return {
	        create: function () {
	            return {
	                has: function (key) {
	                    return key in store;
	                },
	                get: function (key) {
	                    return store[key];
	                },
	                set: function (key, value) {
	                    store[key] = value;
	                },
	            };
	        },
	    };
	}
	// @ts-ignore this is to deal with rollup's default import shenanigans
	var _memoizeIntl = src || memoize$1;
	var memoizeIntl = _memoizeIntl;
	/**
	 * Create intl formatters and populate cache
	 * @param cache explicit cache to prevent leaking memory
	 */
	function createFormatters(cache) {
	    if (cache === void 0) { cache = createIntlCache(); }
	    var RelativeTimeFormat = Intl.RelativeTimeFormat;
	    var ListFormat = Intl.ListFormat;
	    var DisplayNames = Intl.DisplayNames;
	    var getDateTimeFormat = memoizeIntl(function () {
	        var _a;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return new ((_a = Intl.DateTimeFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
	    }, {
	        cache: createFastMemoizeCache(cache.dateTime),
	        strategy: memoizeIntl.strategies.variadic,
	    });
	    var getNumberFormat = memoizeIntl(function () {
	        var _a;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return new ((_a = Intl.NumberFormat).bind.apply(_a, __spreadArrays([void 0], args)))();
	    }, {
	        cache: createFastMemoizeCache(cache.number),
	        strategy: memoizeIntl.strategies.variadic,
	    });
	    var getPluralRules = memoizeIntl(function () {
	        var _a;
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return new ((_a = Intl.PluralRules).bind.apply(_a, __spreadArrays([void 0], args)))();
	    }, {
	        cache: createFastMemoizeCache(cache.pluralRules),
	        strategy: memoizeIntl.strategies.variadic,
	    });
	    return {
	        getDateTimeFormat: getDateTimeFormat,
	        getNumberFormat: getNumberFormat,
	        getMessageFormat: memoizeIntl(function (message, locales, overrideFormats, opts) {
	            return new intlMessageformat.IntlMessageFormat(message, locales, overrideFormats, __assign({ formatters: {
	                    getNumberFormat: getNumberFormat,
	                    getDateTimeFormat: getDateTimeFormat,
	                    getPluralRules: getPluralRules,
	                } }, (opts || {})));
	        }, {
	            cache: createFastMemoizeCache(cache.message),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	        getRelativeTimeFormat: memoizeIntl(function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new (RelativeTimeFormat.bind.apply(RelativeTimeFormat, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.relativeTime),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	        getPluralRules: getPluralRules,
	        getListFormat: memoizeIntl(function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new (ListFormat.bind.apply(ListFormat, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.list),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	        getDisplayNames: memoizeIntl(function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            return new (DisplayNames.bind.apply(DisplayNames, __spreadArrays([void 0], args)))();
	        }, {
	            cache: createFastMemoizeCache(cache.displayNames),
	            strategy: memoizeIntl.strategies.variadic,
	        }),
	    };
	}
	function getNamedFormat(formats, type, name, onError) {
	    var formatType = formats && formats[type];
	    var format;
	    if (formatType) {
	        format = formatType[name];
	    }
	    if (format) {
	        return format;
	    }
	    onError(new UnsupportedFormatterError("No " + type + " format named: " + name));
	}
	/**
	 * Takes a `formatXMLElementFn`, and composes it in function, which passes
	 * argument `parts` through, assigning unique key to each part, to prevent
	 * "Each child in a list should have a unique "key"" React error.
	 * @param formatXMLElementFn
	 */
	function assignUniqueKeysToParts(formatXMLElementFn) {
	    return function (parts) {
	        // eslint-disable-next-line prefer-rest-params
	        return formatXMLElementFn(React.Children.toArray(parts));
	    };
	}

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}var AsyncMode=l;var ConcurrentMode=m;var ContextConsumer=k;var ContextProvider=h;var Element=c;var ForwardRef=n;var Fragment=e;var Lazy=t;var Memo=r;var Portal=d;
	var Profiler=g;var StrictMode=f;var Suspense=p;var isAsyncMode=function(a){return A(a)||z(a)===l};var isConcurrentMode=A;var isContextConsumer=function(a){return z(a)===k};var isContextProvider=function(a){return z(a)===h};var isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};var isForwardRef=function(a){return z(a)===n};var isFragment=function(a){return z(a)===e};var isLazy=function(a){return z(a)===t};
	var isMemo=function(a){return z(a)===r};var isPortal=function(a){return z(a)===d};var isProfiler=function(a){return z(a)===g};var isStrictMode=function(a){return z(a)===f};var isSuspense=function(a){return z(a)===p};
	var isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};var typeOf=z;

	var reactIs_production_min = {
		AsyncMode: AsyncMode,
		ConcurrentMode: ConcurrentMode,
		ContextConsumer: ContextConsumer,
		ContextProvider: ContextProvider,
		Element: Element,
		ForwardRef: ForwardRef,
		Fragment: Fragment,
		Lazy: Lazy,
		Memo: Memo,
		Portal: Portal,
		Profiler: Profiler,
		StrictMode: StrictMode,
		Suspense: Suspense,
		isAsyncMode: isAsyncMode,
		isConcurrentMode: isConcurrentMode,
		isContextConsumer: isContextConsumer,
		isContextProvider: isContextProvider,
		isElement: isElement,
		isForwardRef: isForwardRef,
		isFragment: isFragment,
		isLazy: isLazy,
		isMemo: isMemo,
		isPortal: isPortal,
		isProfiler: isProfiler,
		isStrictMode: isStrictMode,
		isSuspense: isSuspense,
		isValidElementType: isValidElementType,
		typeOf: typeOf
	};

	var reactIs = createCommonjsModule(function (module) {

	{
	  module.exports = reactIs_production_min;
	}
	});

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	var REACT_STATICS = {
	  childContextTypes: true,
	  contextType: true,
	  contextTypes: true,
	  defaultProps: true,
	  displayName: true,
	  getDefaultProps: true,
	  getDerivedStateFromError: true,
	  getDerivedStateFromProps: true,
	  mixins: true,
	  propTypes: true,
	  type: true
	};
	var KNOWN_STATICS = {
	  name: true,
	  length: true,
	  prototype: true,
	  caller: true,
	  callee: true,
	  arguments: true,
	  arity: true
	};
	var FORWARD_REF_STATICS = {
	  '$$typeof': true,
	  render: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true
	};
	var MEMO_STATICS = {
	  '$$typeof': true,
	  compare: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true,
	  type: true
	};
	var TYPE_STATICS = {};
	TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
	TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

	function getStatics(component) {
	  // React v16.11 and below
	  if (reactIs.isMemo(component)) {
	    return MEMO_STATICS;
	  } // React v16.12 and above


	  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
	}

	var defineProperty = Object.defineProperty;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var getPrototypeOf = Object.getPrototypeOf;
	var objectPrototype = Object.prototype;
	function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	  if (typeof sourceComponent !== 'string') {
	    // don't hoist over string (html) components
	    if (objectPrototype) {
	      var inheritedComponent = getPrototypeOf(sourceComponent);

	      if (inheritedComponent && inheritedComponent !== objectPrototype) {
	        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	      }
	    }

	    var keys = getOwnPropertyNames(sourceComponent);

	    if (getOwnPropertySymbols) {
	      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	    }

	    var targetStatics = getStatics(targetComponent);
	    var sourceStatics = getStatics(sourceComponent);

	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i];

	      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
	        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

	        try {
	          // Avoid failures from read-only properties
	          defineProperty(targetComponent, key, descriptor);
	        } catch (e) {}
	      }
	    }
	  }

	  return targetComponent;
	}

	var hoistNonReactStatics_cjs = hoistNonReactStatics;

	var hoistNonReactStatics_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), hoistNonReactStatics_cjs, {
		'default': hoistNonReactStatics_cjs
	}));

	var __assign$1 = (undefined && undefined.__assign) || function () {
	    __assign$1 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$1.apply(this, arguments);
	};
	// Since rollup cannot deal with namespace being a function,
	// this is to interop with TypeScript since `invariant`
	// does not export a default
	// https://github.com/rollup/rollup/issues/1267
	var hoistNonReactStatics$1 = hoistNonReactStatics_cjs || hoistNonReactStatics_;
	function getDisplayName(Component) {
	    return Component.displayName || Component.name || 'Component';
	}
	// TODO: We should provide initial value here
	var IntlContext = React.createContext(null);
	var IntlConsumer = IntlContext.Consumer, IntlProvider = IntlContext.Provider;
	var Provider = IntlProvider;
	var Context = IntlContext;
	function injectIntl(WrappedComponent, options) {
	    var _a = options || {}, _b = _a.intlPropName, intlPropName = _b === void 0 ? 'intl' : _b, _c = _a.forwardRef, forwardRef = _c === void 0 ? false : _c, _d = _a.enforceContext, enforceContext = _d === void 0 ? true : _d;
	    var WithIntl = function (props) { return (React.createElement(IntlConsumer, null, function (intl) {
	        var _a;
	        if (enforceContext) {
	            invariantIntlContext(intl);
	        }
	        var intlProp = (_a = {}, _a[intlPropName] = intl, _a);
	        return (React.createElement(WrappedComponent, __assign$1({}, props, intlProp, { ref: forwardRef ? props.forwardedRef : null })));
	    })); };
	    WithIntl.displayName = "injectIntl(" + getDisplayName(WrappedComponent) + ")";
	    WithIntl.WrappedComponent = WrappedComponent;
	    if (forwardRef) {
	        return hoistNonReactStatics$1(React.forwardRef(function (props, ref) { return (React.createElement(WithIntl, __assign$1({}, props, { forwardedRef: ref }))); }), WrappedComponent);
	    }
	    return hoistNonReactStatics$1(WithIntl, WrappedComponent);
	}

	var __rest = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var DisplayName;
	(function (DisplayName) {
	    DisplayName["formatDate"] = "FormattedDate";
	    DisplayName["formatTime"] = "FormattedTime";
	    DisplayName["formatNumber"] = "FormattedNumber";
	    DisplayName["formatList"] = "FormattedList";
	    // Note that this DisplayName is the locale display name, not to be confused with
	    // the name of the enum, which is for React component display name in dev tools.
	    DisplayName["formatDisplayName"] = "FormattedDisplayName";
	})(DisplayName || (DisplayName = {}));
	var DisplayNameParts;
	(function (DisplayNameParts) {
	    DisplayNameParts["formatDate"] = "FormattedDateParts";
	    DisplayNameParts["formatTime"] = "FormattedTimeParts";
	    DisplayNameParts["formatNumber"] = "FormattedNumberParts";
	    DisplayNameParts["formatList"] = "FormattedListParts";
	})(DisplayNameParts || (DisplayNameParts = {}));
	var FormattedNumberParts = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
	    invariantIntlContext(intl);
	    var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
	    return children(intl.formatNumberToParts(value, formatProps));
	})); };
	FormattedNumberParts.displayName = 'FormattedNumberParts';
	function createFormattedDateTimePartsComponent(name) {
	    var ComponentParts = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
	        invariantIntlContext(intl);
	        var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
	        var date = typeof value === 'string' ? new Date(value || 0) : value;
	        var formattedParts = name === 'formatDate'
	            ? intl.formatDateToParts(date, formatProps)
	            : intl.formatTimeToParts(date, formatProps);
	        return children(formattedParts);
	    })); };
	    ComponentParts.displayName = DisplayNameParts[name];
	    return ComponentParts;
	}
	function createFormattedComponent(name) {
	    var Component = function (props) { return (React.createElement(Context.Consumer, null, function (intl) {
	        invariantIntlContext(intl);
	        var value = props.value, children = props.children, formatProps = __rest(props, ["value", "children"]);
	        // TODO: fix TS type definition for localeMatcher upstream
	        var formattedValue = intl[name](value, formatProps);
	        if (typeof children === 'function') {
	            return children(formattedValue);
	        }
	        var Text = intl.textComponent || React.Fragment;
	        return React.createElement(Text, null, formattedValue);
	    })); };
	    Component.displayName = DisplayName[name];
	    return Component;
	}

	function useIntl() {
	    var intl = React.useContext(Context);
	    invariantIntlContext(intl);
	    return intl;
	}

	var NUMBER_FORMAT_OPTIONS = [
	    'localeMatcher',
	    'style',
	    'currency',
	    'currencyDisplay',
	    'unit',
	    'unitDisplay',
	    'useGrouping',
	    'minimumIntegerDigits',
	    'minimumFractionDigits',
	    'maximumFractionDigits',
	    'minimumSignificantDigits',
	    'maximumSignificantDigits',
	    // ES2020 NumberFormat
	    'compactDisplay',
	    'currencyDisplay',
	    'currencySign',
	    'notation',
	    'signDisplay',
	    'unit',
	    'unitDisplay',
	];
	function getFormatter(_a, getNumberFormat, options) {
	    var locale = _a.locale, formats = _a.formats, onError = _a.onError;
	    if (options === void 0) { options = {}; }
	    var format = options.format;
	    var defaults = ((format &&
	        getNamedFormat(formats, 'number', format, onError)) ||
	        {});
	    var filteredOptions = filterProps(options, NUMBER_FORMAT_OPTIONS, defaults);
	    return getNumberFormat(locale, filteredOptions);
	}
	function formatNumber(config, getNumberFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    try {
	        return getFormatter(config, getNumberFormat, options).format(value);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting number.', e));
	    }
	    return String(value);
	}
	function formatNumberToParts(config, getNumberFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    try {
	        return getFormatter(config, getNumberFormat, options).formatToParts(value);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting number.', e));
	    }
	    return [];
	}

	var RELATIVE_TIME_FORMAT_OPTIONS = ['numeric', 'style'];
	function getFormatter$1(_a, getRelativeTimeFormat, options) {
	    var locale = _a.locale, formats = _a.formats, onError = _a.onError;
	    if (options === void 0) { options = {}; }
	    var format = options.format;
	    var defaults = (!!format && getNamedFormat(formats, 'relative', format, onError)) || {};
	    var filteredOptions = filterProps(options, RELATIVE_TIME_FORMAT_OPTIONS, defaults);
	    return getRelativeTimeFormat(locale, filteredOptions);
	}
	function formatRelativeTime(config, getRelativeTimeFormat, value, unit, options) {
	    if (options === void 0) { options = {}; }
	    if (!unit) {
	        unit = 'second';
	    }
	    var RelativeTimeFormat = Intl.RelativeTimeFormat;
	    if (!RelativeTimeFormat) {
	        config.onError(new intlMessageformat.FormatError("Intl.RelativeTimeFormat is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-relativetimeformat\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
	    }
	    try {
	        return getFormatter$1(config, getRelativeTimeFormat, options).format(value, unit);
	    }
	    catch (e) {
	        config.onError(new MessageFormatError('Error formatting relative time.', e));
	    }
	    return String(value);
	}

	/*
	 * Copyright 2015, Yahoo Inc.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */
	var __assign$2 = (undefined && undefined.__assign) || function () {
	    __assign$2 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$2.apply(this, arguments);
	};
	var DATE_TIME_FORMAT_OPTIONS = [
	    'localeMatcher',
	    'formatMatcher',
	    'timeZone',
	    'hour12',
	    'weekday',
	    'era',
	    'year',
	    'month',
	    'day',
	    'hour',
	    'minute',
	    'second',
	    'timeZoneName',
	    'hourCycle',
	    'dateStyle',
	    'timeStyle',
	    'fractionalSecondDigits',
	    'calendar',
	    // 'dayPeriod',
	    'numberingSystem',
	];
	function getFormatter$2(_a, type, getDateTimeFormat, options) {
	    var locale = _a.locale, formats = _a.formats, onError = _a.onError, timeZone = _a.timeZone;
	    if (options === void 0) { options = {}; }
	    var format = options.format;
	    var defaults = __assign$2(__assign$2({}, (timeZone && { timeZone: timeZone })), (format && getNamedFormat(formats, type, format, onError)));
	    var filteredOptions = filterProps(options, DATE_TIME_FORMAT_OPTIONS, defaults);
	    if (type === 'time' &&
	        !filteredOptions.hour &&
	        !filteredOptions.minute &&
	        !filteredOptions.second) {
	        // Add default formatting options if hour, minute, or second isn't defined.
	        filteredOptions = __assign$2(__assign$2({}, filteredOptions), { hour: 'numeric', minute: 'numeric' });
	    }
	    return getDateTimeFormat(locale, filteredOptions);
	}
	function formatDate(config, getDateTimeFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    var date = typeof value === 'string' ? new Date(value || 0) : value;
	    try {
	        return getFormatter$2(config, 'date', getDateTimeFormat, options).format(date);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting date.', e));
	    }
	    return String(date);
	}
	function formatTime(config, getDateTimeFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    var date = typeof value === 'string' ? new Date(value || 0) : value;
	    try {
	        return getFormatter$2(config, 'time', getDateTimeFormat, options).format(date);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting time.', e));
	    }
	    return String(date);
	}
	function formatDateToParts(config, getDateTimeFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    var date = typeof value === 'string' ? new Date(value || 0) : value;
	    try {
	        return getFormatter$2(config, 'date', getDateTimeFormat, options).formatToParts(date);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting date.', e));
	    }
	    return [];
	}
	function formatTimeToParts(config, getDateTimeFormat, value, options) {
	    if (options === void 0) { options = {}; }
	    var date = typeof value === 'string' ? new Date(value || 0) : value;
	    try {
	        return getFormatter$2(config, 'time', getDateTimeFormat, options).formatToParts(date);
	    }
	    catch (e) {
	        config.onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting time.', e));
	    }
	    return [];
	}

	var PLURAL_FORMAT_OPTIONS = [
	    'localeMatcher',
	    'type',
	];
	function formatPlural(_a, getPluralRules, value, options) {
	    var locale = _a.locale, onError = _a.onError;
	    if (options === void 0) { options = {}; }
	    if (!Intl.PluralRules) {
	        onError(new intlMessageformat.FormatError("Intl.PluralRules is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-pluralrules\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
	    }
	    var filteredOptions = filterProps(options, PLURAL_FORMAT_OPTIONS);
	    try {
	        return getPluralRules(locale, filteredOptions).select(value);
	    }
	    catch (e) {
	        onError(new MessageFormatError('Error formatting plural.', e));
	    }
	    return 'other';
	}

	/*
	 * Copyright 2015, Yahoo Inc.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */
	var __assign$3 = (undefined && undefined.__assign) || function () {
	    __assign$3 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$3.apply(this, arguments);
	};
	var __spreadArrays$1 = (undefined && undefined.__spreadArrays) || function () {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	};
	function setTimeZoneInOptions(opts, timeZone) {
	    return Object.keys(opts).reduce(function (all, k) {
	        all[k] = __assign$3({ timeZone: timeZone }, opts[k]);
	        return all;
	    }, {});
	}
	function deepMergeOptions(opts1, opts2) {
	    var keys = Object.keys(__assign$3(__assign$3({}, opts1), opts2));
	    return keys.reduce(function (all, k) {
	        all[k] = __assign$3(__assign$3({}, (opts1[k] || {})), (opts2[k] || {}));
	        return all;
	    }, {});
	}
	function deepMergeFormatsAndSetTimeZone(f1, timeZone) {
	    if (!timeZone) {
	        return f1;
	    }
	    var mfFormats = intlMessageformat.IntlMessageFormat.formats;
	    return __assign$3(__assign$3(__assign$3({}, mfFormats), f1), { date: deepMergeOptions(setTimeZoneInOptions(mfFormats.date, timeZone), setTimeZoneInOptions(f1.date || {}, timeZone)), time: deepMergeOptions(setTimeZoneInOptions(mfFormats.time, timeZone), setTimeZoneInOptions(f1.time || {}, timeZone)) });
	}
	function assignUniqueKeysToFormatXMLElementFnArgument(values) {
	    return Object.keys(values).reduce(function (acc, k) {
	        var v = values[k];
	        acc[k] = intlMessageformat.isFormatXMLElementFn(v)
	            ? assignUniqueKeysToParts(v)
	            : v;
	        return acc;
	    }, {});
	}
	function prepareIntlMessageFormatHtmlOutput(chunks, shouldWrap) {
	    return Array.isArray(chunks) && shouldWrap
	        ? React.createElement.apply(React__namespace, __spreadArrays$1([React.Fragment, null], chunks)) : chunks;
	}
	function formatMessage(_a, state, messageDescriptor, values) {
	    var locale = _a.locale, formats = _a.formats, messages = _a.messages, defaultLocale = _a.defaultLocale, defaultFormats = _a.defaultFormats, onError = _a.onError, timeZone = _a.timeZone, wrapRichTextChunksInFragment = _a.wrapRichTextChunksInFragment, defaultRichTextElements = _a.defaultRichTextElements;
	    if (messageDescriptor === void 0) { messageDescriptor = { id: '' }; }
	    var msgId = messageDescriptor.id, defaultMessage = messageDescriptor.defaultMessage;
	    // `id` is a required field of a Message Descriptor.
	    intlUtils.invariant(!!msgId, '[React Intl] An `id` must be provided to format a message.');
	    var id = String(msgId);
	    var message = 
	    // In case messages is Object.create(null)
	    // e.g import('foo.json') from webpack)
	    // See https://github.com/formatjs/formatjs/issues/1914
	    messages &&
	        Object.prototype.hasOwnProperty.call(messages, id) &&
	        messages[id];
	    // IMPORTANT: Hot path if `message` is AST with a single literal node
	    if (Array.isArray(message) &&
	        message.length === 1 &&
	        message[0].type === dummy.TYPE.literal) {
	        return message[0].value;
	    }
	    if (!values &&
	        message &&
	        typeof message === 'string' &&
	        defaultRichTextElements) {
	        console.error("[React Intl] \"defaultRichTextElements\" was specified but \"message\" was not pre-compiled. \nPlease consider using \"@formatjs/cli\" to pre-compile your messages for performance.\nFor more details see https://formatjs.io/docs/getting-started/message-distribution");
	    }
	    // IMPORTANT: Hot path straight lookup for performance
	    if (!values &&
	        message &&
	        typeof message === 'string' &&
	        !defaultRichTextElements) {
	        return message.replace(/'\{(.*?)\}'/gi, "{$1}");
	    }
	    var patchedValues = assignUniqueKeysToFormatXMLElementFnArgument(__assign$3(__assign$3({}, defaultRichTextElements), (values || {})));
	    formats = deepMergeFormatsAndSetTimeZone(formats, timeZone);
	    defaultFormats = deepMergeFormatsAndSetTimeZone(defaultFormats, timeZone);
	    if (!message) {
	        if (!defaultMessage ||
	            (locale && locale.toLowerCase() !== defaultLocale.toLowerCase())) {
	            // This prevents warnings from littering the console in development
	            // when no `messages` are passed into the <IntlProvider> for the
	            // default locale.
	            onError(new MissingTranslationError(messageDescriptor, locale));
	        }
	        if (defaultMessage) {
	            try {
	                var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);
	                return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);
	            }
	            catch (e) {
	                onError(new MessageFormatError("Error formatting default message for: \"" + id + "\", rendering default message verbatim", locale, messageDescriptor, e));
	                return defaultMessage;
	            }
	        }
	        return id;
	    }
	    // We have the translated message
	    try {
	        var formatter = state.getMessageFormat(message, locale, formats, {
	            formatters: state,
	        });
	        return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);
	    }
	    catch (e) {
	        onError(new MessageFormatError("Error formatting message: \"" + id + "\", using " + (defaultMessage ? 'default message' : 'id') + " as fallback.", locale, messageDescriptor, e));
	    }
	    if (defaultMessage) {
	        try {
	            var formatter = state.getMessageFormat(defaultMessage, defaultLocale, defaultFormats);
	            return prepareIntlMessageFormatHtmlOutput(formatter.format(patchedValues), wrapRichTextChunksInFragment);
	        }
	        catch (e) {
	            onError(new MessageFormatError("Error formatting the default message for: \"" + id + "\", rendering message verbatim", locale, messageDescriptor, e));
	        }
	    }
	    return message || defaultMessage || id;
	}

	function shallowEqualObjects(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }

	  if (!objA || !objB) {
	    return false;
	  }

	  var aKeys = Object.keys(objA);
	  var bKeys = Object.keys(objB);
	  var len = aKeys.length;

	  if (bKeys.length !== len) {
	    return false;
	  }

	  for (var i = 0; i < len; i++) {
	    var key = aKeys[i];

	    if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {
	      return false;
	    }
	  }

	  return true;
	}

	var objects = shallowEqualObjects;

	var shallowEquals_ = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), objects, {
		'default': objects
	}));

	var LIST_FORMAT_OPTIONS = [
	    'localeMatcher',
	    'type',
	    'style',
	];
	var now = Date.now();
	function generateToken(i) {
	    return now + "_" + i + "_" + now;
	}
	function formatList(_a, getListFormat, values, options) {
	    var locale = _a.locale, onError = _a.onError;
	    if (options === void 0) { options = {}; }
	    var ListFormat = Intl.ListFormat;
	    if (!ListFormat) {
	        onError(new intlMessageformat.FormatError("Intl.ListFormat is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-listformat\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
	    }
	    var filteredOptions = filterProps(options, LIST_FORMAT_OPTIONS);
	    try {
	        var richValues_1 = {};
	        var serializedValues = values.map(function (v, i) {
	            if (typeof v === 'object') {
	                var id = generateToken(i);
	                richValues_1[id] = v;
	                return id;
	            }
	            return String(v);
	        });
	        if (!Object.keys(richValues_1).length) {
	            return getListFormat(locale, filteredOptions).format(serializedValues);
	        }
	        var parts = getListFormat(locale, filteredOptions).formatToParts(serializedValues);
	        return parts.reduce(function (all, el) {
	            var val = el.value;
	            if (richValues_1[val]) {
	                all.push(richValues_1[val]);
	            }
	            else if (typeof all[all.length - 1] === 'string') {
	                all[all.length - 1] += val;
	            }
	            else {
	                all.push(val);
	            }
	            return all;
	        }, []);
	    }
	    catch (e) {
	        onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting list.', e));
	    }
	    return values;
	}

	var DISPLAY_NAMES_OPTONS = [
	    'localeMatcher',
	    'style',
	    'type',
	    'fallback',
	];
	function formatDisplayName(_a, getDisplayNames, value, options) {
	    var locale = _a.locale, onError = _a.onError;
	    if (options === void 0) { options = {}; }
	    var DisplayNames = Intl.DisplayNames;
	    if (!DisplayNames) {
	        onError(new intlMessageformat.FormatError("Intl.DisplayNames is not available in this environment.\nTry polyfilling it using \"@formatjs/intl-displaynames\"\n", "MISSING_INTL_API" /* MISSING_INTL_API */));
	    }
	    var filteredOptions = filterProps(options, DISPLAY_NAMES_OPTONS);
	    try {
	        return getDisplayNames(locale, filteredOptions).of(value);
	    }
	    catch (e) {
	        onError(new ReactIntlError("FORMAT_ERROR" /* FORMAT_ERROR */, 'Error formatting display name.', e));
	    }
	}

	/*
	 * Copyright 2015, Yahoo Inc.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */
	var __extends$1 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$4 = (undefined && undefined.__assign) || function () {
	    __assign$4 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$4.apply(this, arguments);
	};
	var shallowEquals = objects || shallowEquals_;
	function processIntlConfig(config) {
	    return {
	        locale: config.locale,
	        timeZone: config.timeZone,
	        formats: config.formats,
	        textComponent: config.textComponent,
	        messages: config.messages,
	        defaultLocale: config.defaultLocale,
	        defaultFormats: config.defaultFormats,
	        onError: config.onError,
	        wrapRichTextChunksInFragment: config.wrapRichTextChunksInFragment,
	        defaultRichTextElements: config.defaultRichTextElements,
	    };
	}
	/**
	 * Create intl object
	 * @param config intl config
	 * @param cache cache for formatter instances to prevent memory leak
	 */
	function createIntl(config, cache) {
	    var formatters = createFormatters(cache);
	    var resolvedConfig = __assign$4(__assign$4({}, DEFAULT_INTL_CONFIG), config);
	    var locale = resolvedConfig.locale, defaultLocale = resolvedConfig.defaultLocale, onError = resolvedConfig.onError;
	    if (!locale) {
	        if (onError) {
	            onError(new InvalidConfigError("\"locale\" was not configured, using \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl/api#intlshape for more details"));
	        }
	        // Since there's no registered locale data for `locale`, this will
	        // fallback to the `defaultLocale` to make sure things can render.
	        // The `messages` are overridden to the `defaultProps` empty object
	        // to maintain referential equality across re-renders. It's assumed
	        // each <FormattedMessage> contains a `defaultMessage` prop.
	        resolvedConfig.locale = resolvedConfig.defaultLocale || 'en';
	    }
	    else if (!Intl.NumberFormat.supportedLocalesOf(locale).length && onError) {
	        onError(new MissingDataError("Missing locale data for locale: \"" + locale + "\" in Intl.NumberFormat. Using default locale: \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details"));
	    }
	    else if (!Intl.DateTimeFormat.supportedLocalesOf(locale).length &&
	        onError) {
	        onError(new MissingDataError("Missing locale data for locale: \"" + locale + "\" in Intl.DateTimeFormat. Using default locale: \"" + defaultLocale + "\" as fallback. See https://formatjs.io/docs/react-intl#runtime-requirements for more details"));
	    }
	    return __assign$4(__assign$4({}, resolvedConfig), { formatters: formatters, formatNumber: formatNumber.bind(null, resolvedConfig, formatters.getNumberFormat), formatNumberToParts: formatNumberToParts.bind(null, resolvedConfig, formatters.getNumberFormat), formatRelativeTime: formatRelativeTime.bind(null, resolvedConfig, formatters.getRelativeTimeFormat), formatDate: formatDate.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatDateToParts: formatDateToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTime: formatTime.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatTimeToParts: formatTimeToParts.bind(null, resolvedConfig, formatters.getDateTimeFormat), formatPlural: formatPlural.bind(null, resolvedConfig, formatters.getPluralRules), formatMessage: formatMessage.bind(null, resolvedConfig, formatters), formatList: formatList.bind(null, resolvedConfig, formatters.getListFormat), formatDisplayName: formatDisplayName.bind(null, resolvedConfig, formatters.getDisplayNames) });
	}
	var IntlProvider$1 = /** @class */ (function (_super) {
	    __extends$1(IntlProvider, _super);
	    function IntlProvider() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.cache = createIntlCache();
	        _this.state = {
	            cache: _this.cache,
	            intl: createIntl(processIntlConfig(_this.props), _this.cache),
	            prevConfig: processIntlConfig(_this.props),
	        };
	        return _this;
	    }
	    IntlProvider.getDerivedStateFromProps = function (props, _a) {
	        var prevConfig = _a.prevConfig, cache = _a.cache;
	        var config = processIntlConfig(props);
	        if (!shallowEquals(prevConfig, config)) {
	            return {
	                intl: createIntl(config, cache),
	                prevConfig: config,
	            };
	        }
	        return null;
	    };
	    IntlProvider.prototype.render = function () {
	        invariantIntlContext(this.state.intl);
	        return React.createElement(Provider, { value: this.state.intl }, this.props.children);
	    };
	    IntlProvider.displayName = 'IntlProvider';
	    IntlProvider.defaultProps = DEFAULT_INTL_CONFIG;
	    return IntlProvider;
	}(React.PureComponent));

	var __extends$2 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign$5 = (undefined && undefined.__assign) || function () {
	    __assign$5 = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign$5.apply(this, arguments);
	};
	var MINUTE = 60;
	var HOUR = 60 * 60;
	var DAY = 60 * 60 * 24;
	function selectUnit(seconds) {
	    var absValue = Math.abs(seconds);
	    if (absValue < MINUTE) {
	        return 'second';
	    }
	    if (absValue < HOUR) {
	        return 'minute';
	    }
	    if (absValue < DAY) {
	        return 'hour';
	    }
	    return 'day';
	}
	function getDurationInSeconds(unit) {
	    switch (unit) {
	        case 'second':
	            return 1;
	        case 'minute':
	            return MINUTE;
	        case 'hour':
	            return HOUR;
	        default:
	            return DAY;
	    }
	}
	function valueToSeconds(value, unit) {
	    if (!value) {
	        return 0;
	    }
	    switch (unit) {
	        case 'second':
	            return value;
	        case 'minute':
	            return value * MINUTE;
	        default:
	            return value * HOUR;
	    }
	}
	var INCREMENTABLE_UNITS = ['second', 'minute', 'hour'];
	function canIncrement(unit) {
	    if (unit === void 0) { unit = 'second'; }
	    return INCREMENTABLE_UNITS.includes(unit);
	}
	var FormattedRelativeTime = /** @class */ (function (_super) {
	    __extends$2(FormattedRelativeTime, _super);
	    function FormattedRelativeTime(props) {
	        var _this = _super.call(this, props) || this;
	        // Public for testing
	        _this._updateTimer = null;
	        _this.state = {
	            prevUnit: _this.props.unit,
	            prevValue: _this.props.value,
	            currentValueInSeconds: canIncrement(_this.props.unit)
	                ? valueToSeconds(_this.props.value, _this.props.unit)
	                : 0,
	        };
	        intlUtils.invariant(!props.updateIntervalInSeconds ||
	            !!(props.updateIntervalInSeconds && canIncrement(props.unit)), 'Cannot schedule update with unit longer than hour');
	        return _this;
	    }
	    FormattedRelativeTime.prototype.scheduleNextUpdate = function (_a, _b) {
	        var _this = this;
	        var updateIntervalInSeconds = _a.updateIntervalInSeconds, unit = _a.unit;
	        var currentValueInSeconds = _b.currentValueInSeconds;
	        clearTimeout(this._updateTimer);
	        this._updateTimer = null;
	        // If there's no interval and we cannot increment this unit, do nothing
	        if (!updateIntervalInSeconds || !canIncrement(unit)) {
	            return;
	        }
	        // Figure out the next interesting time
	        var nextValueInSeconds = currentValueInSeconds - updateIntervalInSeconds;
	        var nextUnit = selectUnit(nextValueInSeconds);
	        // We've reached the max auto incrementable unit, don't schedule another update
	        if (nextUnit === 'day') {
	            return;
	        }
	        var unitDuration = getDurationInSeconds(nextUnit);
	        var remainder = nextValueInSeconds % unitDuration;
	        var prevInterestingValueInSeconds = nextValueInSeconds - remainder;
	        var nextInterestingValueInSeconds = prevInterestingValueInSeconds >= currentValueInSeconds
	            ? prevInterestingValueInSeconds - unitDuration
	            : prevInterestingValueInSeconds;
	        var delayInSeconds = Math.abs(nextInterestingValueInSeconds - currentValueInSeconds);
	        this._updateTimer = setTimeout(function () {
	            return _this.setState({
	                currentValueInSeconds: nextInterestingValueInSeconds,
	            });
	        }, delayInSeconds * 1e3);
	    };
	    FormattedRelativeTime.prototype.componentDidMount = function () {
	        this.scheduleNextUpdate(this.props, this.state);
	    };
	    FormattedRelativeTime.prototype.componentDidUpdate = function () {
	        this.scheduleNextUpdate(this.props, this.state);
	    };
	    FormattedRelativeTime.prototype.componentWillUnmount = function () {
	        clearTimeout(this._updateTimer);
	        this._updateTimer = null;
	    };
	    FormattedRelativeTime.getDerivedStateFromProps = function (props, state) {
	        if (props.unit !== state.prevUnit || props.value !== state.prevValue) {
	            return {
	                prevValue: props.value,
	                prevUnit: props.unit,
	                currentValueInSeconds: canIncrement(props.unit)
	                    ? valueToSeconds(props.value, props.unit)
	                    : 0,
	            };
	        }
	        return null;
	    };
	    FormattedRelativeTime.prototype.render = function () {
	        var _this = this;
	        return (React.createElement(Context.Consumer, null, function (intl) {
	            invariantIntlContext(intl);
	            var formatRelativeTime = intl.formatRelativeTime, Text = intl.textComponent;
	            var _a = _this.props, children = _a.children, value = _a.value, unit = _a.unit, updateIntervalInSeconds = _a.updateIntervalInSeconds;
	            var currentValueInSeconds = _this.state.currentValueInSeconds;
	            var currentValue = value || 0;
	            var currentUnit = unit;
	            if (canIncrement(unit) &&
	                typeof currentValueInSeconds === 'number' &&
	                updateIntervalInSeconds) {
	                currentUnit = selectUnit(currentValueInSeconds);
	                var unitDuration = getDurationInSeconds(currentUnit);
	                currentValue = Math.round(currentValueInSeconds / unitDuration);
	            }
	            var formattedRelativeTime = formatRelativeTime(currentValue, currentUnit, __assign$5({}, _this.props));
	            if (typeof children === 'function') {
	                return children(formattedRelativeTime);
	            }
	            if (Text) {
	                return React.createElement(Text, null, formattedRelativeTime);
	            }
	            return formattedRelativeTime;
	        }));
	    };
	    FormattedRelativeTime.displayName = 'FormattedRelativeTime';
	    FormattedRelativeTime.defaultProps = {
	        value: 0,
	        unit: 'second',
	    };
	    return FormattedRelativeTime;
	}(React.PureComponent));

	/*
	 * Copyright 2015, Yahoo Inc.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */
	var FormattedPlural = function (props) {
	    var value = props.value, other = props.other, children = props.children, _a = props.intl, formatPlural = _a.formatPlural, Text = _a.textComponent;
	    var pluralCategory = formatPlural(value, props);
	    var formattedPlural = props[pluralCategory] || other;
	    if (typeof children === 'function') {
	        return children(formattedPlural);
	    }
	    if (Text) {
	        return React.createElement(Text, null, formattedPlural);
	    }
	    // Work around @types/react where React.FC cannot return string
	    return formattedPlural;
	};
	FormattedPlural.defaultProps = {
	    type: 'cardinal',
	};
	FormattedPlural.displayName = 'FormattedPlural';
	// Explicitly annotate type here to workaround API extractor's inability to handle `import('./someModule')`
	// type annotations when rolling up DTS file.
	var FormattedPluralWithIntl = injectIntl(FormattedPlural);

	/*
	 * Copyright 2015, Yahoo Inc.
	 * Copyrights licensed under the New BSD License.
	 * See the accompanying LICENSE file for terms.
	 */
	var __extends$3 = (undefined && undefined.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
	    var t = {};
	    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	        t[p] = s[p];
	    if (s != null && typeof Object.getOwnPropertySymbols === "function")
	        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                t[p[i]] = s[p[i]];
	        }
	    return t;
	};
	var __spreadArrays$2 = (undefined && undefined.__spreadArrays) || function () {
	    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	    for (var r = Array(s), k = 0, i = 0; i < il; i++)
	        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	            r[k] = a[j];
	    return r;
	};
	var shallowEquals$1 = objects || shallowEquals_;
	var FormattedMessage = /** @class */ (function (_super) {
	    __extends$3(FormattedMessage, _super);
	    function FormattedMessage() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    FormattedMessage.prototype.shouldComponentUpdate = function (nextProps) {
	        var _a = this.props, values = _a.values, otherProps = __rest$1(_a, ["values"]);
	        var nextValues = nextProps.values, nextOtherProps = __rest$1(nextProps, ["values"]);
	        return (!shallowEquals$1(nextValues, values) ||
	            !shallowEquals$1(otherProps, nextOtherProps));
	    };
	    FormattedMessage.prototype.render = function () {
	        var _this = this;
	        return (React.createElement(Context.Consumer, null, function (intl) {
	            invariantIntlContext(intl);
	            var formatMessage = intl.formatMessage, _a = intl.textComponent, Text = _a === void 0 ? React.Fragment : _a;
	            var _b = _this.props, id = _b.id, description = _b.description, defaultMessage = _b.defaultMessage, values = _b.values, children = _b.children, _c = _b.tagName, Component = _c === void 0 ? Text : _c;
	            var descriptor = { id: id, description: description, defaultMessage: defaultMessage };
	            var nodes = formatMessage(descriptor, values);
	            if (!Array.isArray(nodes)) {
	                nodes = [nodes];
	            }
	            if (typeof children === 'function') {
	                return children(nodes);
	            }
	            if (Component) {
	                // Needs to use `createElement()` instead of JSX, otherwise React will
	                // warn about a missing `key` prop with rich-text message formatting.
	                return React.createElement.apply(React__namespace, __spreadArrays$2([Component, null], nodes));
	            }
	            return nodes;
	        }));
	    };
	    FormattedMessage.displayName = 'FormattedMessage';
	    return FormattedMessage;
	}(React.Component));

	function defineMessages(msgs) {
	    return msgs;
	}
	function defineMessage(msg) {
	    return msg;
	}
	// IMPORTANT: Explicit here to prevent api-extractor from outputing `import('./src/types').CustomFormatConfig`
	var FormattedDate = createFormattedComponent('formatDate');
	var FormattedTime = createFormattedComponent('formatTime');
	var FormattedNumber = createFormattedComponent('formatNumber');
	var FormattedList = createFormattedComponent('formatList');
	var FormattedDisplayName = createFormattedComponent('formatDisplayName');
	var FormattedDateParts = createFormattedDateTimePartsComponent('formatDate');
	var FormattedTimeParts = createFormattedDateTimePartsComponent('formatTime');

	exports.FormattedDate = FormattedDate;
	exports.FormattedDateParts = FormattedDateParts;
	exports.FormattedDisplayName = FormattedDisplayName;
	exports.FormattedList = FormattedList;
	exports.FormattedMessage = FormattedMessage;
	exports.FormattedNumber = FormattedNumber;
	exports.FormattedNumberParts = FormattedNumberParts;
	exports.FormattedPlural = FormattedPluralWithIntl;
	exports.FormattedRelativeTime = FormattedRelativeTime;
	exports.FormattedTime = FormattedTime;
	exports.FormattedTimeParts = FormattedTimeParts;
	exports.IntlContext = Context;
	exports.IntlProvider = IntlProvider$1;
	exports.InvalidConfigError = InvalidConfigError;
	exports.MessageFormatError = MessageFormatError;
	exports.MissingDataError = MissingDataError;
	exports.MissingTranslationError = MissingTranslationError;
	exports.RawIntlProvider = Provider;
	exports.ReactIntlError = ReactIntlError;
	exports.UnsupportedFormatterError = UnsupportedFormatterError;
	exports.createIntl = createIntl;
	exports.createIntlCache = createIntlCache;
	exports.defineMessage = defineMessage;
	exports.defineMessages = defineMessages;
	exports.injectIntl = injectIntl;
	exports.useIntl = useIntl;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=react-intl-no-parser.umd.js.map
